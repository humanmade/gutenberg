{"version":3,"sources":["/home/circleci/project/packages/url/src/index.js"],"names":["parse","stringify","URL_REGEXP","EMAIL_REGEXP","USABLE_HREF_REGEXP","isURL","url","test","getProtocol","matches","exec","isValidProtocol","protocol","getAuthority","isValidAuthority","authority","getPath","isValidPath","path","getQueryString","isValidQueryString","queryString","getFragment","isValidFragment","fragment","addQueryArgs","args","queryStringIndex","indexOf","query","substr","baseUrl","getQueryArg","arg","hasQueryArg","undefined","removeQueryArgs","forEach","prependHTTP","safeDecodeURI","uri","decodeURI","uriError","filterURLForDisplay","filteredURL","replace","match"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { parse, stringify } from 'qs';\n\nconst URL_REGEXP = /^(?:https?:)?\\/\\/\\S+$/i;\nconst EMAIL_REGEXP = /^(mailto:)?[a-z0-9._%+-]+@[a-z0-9][a-z0-9.-]*\\.[a-z]{2,63}$/i;\nconst USABLE_HREF_REGEXP = /^(?:[a-z]+:|#|\\?|\\.|\\/)/i;\n\n/**\n * Determines whether the given string looks like a URL.\n *\n * @param {string} url The string to scrutinise.\n *\n * @return {boolean} Whether or not it looks like a URL.\n */\nexport function isURL( url ) {\n\treturn URL_REGEXP.test( url );\n}\n\n/**\n * Returns the protocol part of the URL.\n *\n * @param {string} url The full URL.\n *\n * @return {?string} The protocol part of the URL.\n */\nexport function getProtocol( url ) {\n\tconst matches = /^([^\\s:]+:)/.exec( url );\n\tif ( matches ) {\n\t\treturn matches[ 1 ];\n\t}\n}\n\n/**\n * Tests if a url protocol is valid.\n *\n * @param {string} protocol The url protocol.\n *\n * @return {boolean} True if the argument is a valid protocol (e.g. http://, tel:).\n */\nexport function isValidProtocol( protocol ) {\n\tif ( ! protocol ) {\n\t\treturn false;\n\t}\n\treturn /^[a-z\\-.\\+]+[0-9]*:(?:\\/\\/)?\\/?$/i.test( protocol );\n}\n\n/**\n * Returns the authority part of the URL.\n *\n * @param {string} url The full URL.\n *\n * @return {?string} The authority part of the URL.\n */\nexport function getAuthority( url ) {\n\tconst matches = /^[^\\/\\s:]+:(?:\\/\\/)?\\/?([^\\/\\s#?]+)[\\/#?]{0,1}\\S*$/.exec( url );\n\tif ( matches ) {\n\t\treturn matches[ 1 ];\n\t}\n}\n\n/**\n * Checks for invalid characters within the provided authority.\n *\n * @param {string} authority A string containing the URL authority.\n *\n * @return {boolean} True if the argument contains a valid authority.\n */\nexport function isValidAuthority( authority ) {\n\tif ( ! authority ) {\n\t\treturn false;\n\t}\n\treturn /^[^\\s#?]+$/.test( authority );\n}\n\n/**\n * Returns the path part of the URL.\n *\n * @param {string} url The full URL.\n *\n * @return {?string} The path part of the URL.\n */\nexport function getPath( url ) {\n\tconst matches = /^[^\\/\\s:]+:(?:\\/\\/)?[^\\/\\s#?]+[\\/]([^\\s#?]+)[#?]{0,1}\\S*$/.exec( url );\n\tif ( matches ) {\n\t\treturn matches[ 1 ];\n\t}\n}\n\n/**\n * Checks for invalid characters within the provided path.\n *\n * @param {string} path The URL path.\n *\n * @return {boolean} True if the argument contains a valid path\n */\nexport function isValidPath( path ) {\n\tif ( ! path ) {\n\t\treturn false;\n\t}\n\treturn /^[^\\s#?]+$/.test( path );\n}\n\n/**\n * Returns the query string part of the URL.\n *\n * @param {string} url The full URL.\n *\n * @return {?string} The query string part of the URL.\n */\nexport function getQueryString( url ) {\n\tconst matches = /^\\S+?\\?([^\\s#]+)/.exec( url );\n\tif ( matches ) {\n\t\treturn matches[ 1 ];\n\t}\n}\n\n/**\n * Checks for invalid characters within the provided query string.\n *\n * @param {string} queryString The query string.\n *\n * @return {boolean} True if the argument contains a valid query string.\n */\nexport function isValidQueryString( queryString ) {\n\tif ( ! queryString ) {\n\t\treturn false;\n\t}\n\treturn /^[^\\s#?\\/]+$/.test( queryString );\n}\n\n/**\n * Returns the fragment part of the URL.\n *\n * @param {string} url The full URL\n *\n * @return {?string} The fragment part of the URL.\n */\nexport function getFragment( url ) {\n\tconst matches = /^\\S+(#[^\\s\\?]*)/.exec( url );\n\tif ( matches ) {\n\t\treturn matches[ 1 ];\n\t}\n}\n\n/**\n * Checks for invalid characters within the provided fragment.\n *\n * @param {string} fragment The url fragment.\n *\n * @return {boolean} True if the argument contains a valid fragment.\n */\nexport function isValidFragment( fragment ) {\n\tif ( ! fragment ) {\n\t\treturn false;\n\t}\n\treturn /^#[^\\s#?\\/]*$/.test( fragment );\n}\n\n/**\n * Appends arguments to the query string of the url\n *\n * @param {string} url  URL\n * @param {Object} args Query Args\n *\n * @return {string} Updated URL\n */\nexport function addQueryArgs( url, args ) {\n\tconst queryStringIndex = url.indexOf( '?' );\n\tconst query = queryStringIndex !== -1 ? parse( url.substr( queryStringIndex + 1 ) ) : {};\n\tconst baseUrl = queryStringIndex !== -1 ? url.substr( 0, queryStringIndex ) : url;\n\n\treturn baseUrl + '?' + stringify( { ...query, ...args } );\n}\n\n/**\n * Returns a single query argument of the url\n *\n * @param {string} url URL\n * @param {string} arg Query arg name\n *\n * @return {Array|string} Query arg value.\n */\nexport function getQueryArg( url, arg ) {\n\tconst queryStringIndex = url.indexOf( '?' );\n\tconst query = queryStringIndex !== -1 ? parse( url.substr( queryStringIndex + 1 ) ) : {};\n\n\treturn query[ arg ];\n}\n\n/**\n * Determines whether the URL contains a given query arg.\n *\n * @param {string} url URL\n * @param {string} arg Query arg name\n *\n * @return {boolean} Whether or not the URL contains the query aeg.\n */\nexport function hasQueryArg( url, arg ) {\n\treturn getQueryArg( url, arg ) !== undefined;\n}\n\n/**\n * Removes arguments from the query string of the url\n *\n * @param {string} url  URL\n * @param {...string} args Query Args\n *\n * @return {string} Updated URL\n */\nexport function removeQueryArgs( url, ...args ) {\n\tconst queryStringIndex = url.indexOf( '?' );\n\tconst query = queryStringIndex !== -1 ? parse( url.substr( queryStringIndex + 1 ) ) : {};\n\tconst baseUrl = queryStringIndex !== -1 ? url.substr( 0, queryStringIndex ) : url;\n\n\targs.forEach( ( arg ) => delete query[ arg ] );\n\n\treturn baseUrl + '?' + stringify( query );\n}\n\n/**\n * Prepends \"http://\" to a url, if it looks like something that is meant to be a TLD.\n *\n * @param  {string} url The URL to test\n *\n * @return {string}     The updated URL\n */\nexport function prependHTTP( url ) {\n\tif ( ! USABLE_HREF_REGEXP.test( url ) && ! EMAIL_REGEXP.test( url ) ) {\n\t\treturn 'http://' + url;\n\t}\n\n\treturn url;\n}\n\n/**\n * Safely decodes a URI with `decodeURI`. Returns the URI unmodified if\n * `decodeURI` throws an error.\n *\n * @param {string} uri URI to decode.\n *\n * @return {string} Decoded URI if possible.\n */\nexport function safeDecodeURI( uri ) {\n\ttry {\n\t\treturn decodeURI( uri );\n\t} catch ( uriError ) {\n\t\treturn uri;\n\t}\n}\n\n/**\n * Returns a URL for display.\n *\n * @param {string} url Original URL.\n *\n * @return {string} Displayed URL.\n */\nexport function filterURLForDisplay( url ) {\n\t// Remove protocol and www prefixes.\n\tconst filteredURL = url.replace( /^(?:https?:)\\/\\/(?:www\\.)?/, '' );\n\n\t// Ends with / and only has that single slash, strip it.\n\tif ( filteredURL.match( /^[^\\/]+\\/$/ ) ) {\n\t\treturn filteredURL.replace( '/', '' );\n\t}\n\n\treturn filteredURL;\n}\n"]}