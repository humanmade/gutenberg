{"version":3,"sources":["/home/circleci/project/packages/rich-text/src/to-dom.js"],"names":["window","Node","TEXT_NODE","ELEMENT_NODE","createPathToNode","node","rootNode","path","parentNode","i","previousSibling","getNodeByPath","length","childNodes","shift","offset","createEmpty","document","implementation","createHTMLDocument","body","append","element","child","ownerDocument","createTextNode","type","attributes","createElement","key","setAttribute","appendChild","appendText","text","appendData","getLastChild","lastChild","getParent","isText","nodeType","getText","nodeValue","remove","removeChild","padEmptyLines","createLinePadding","multilineWrapperTags","doc","index","indexOf","nodeName","toLowerCase","insertBefore","prepareFormats","prepareEditableTree","value","reduce","accumlator","fn","formats","toDom","multilineTag","startPath","endPath","tree","onStartIndex","pointer","onEndIndex","isEditableTree","selection","apply","current","applyValue","start","undefined","applySelection","future","firstChild","currentChild","futureNodeType","replaceChild","startContainer","startOffset","endContainer","endOffset","windowSelection","getSelection","range","createRange","collapsed","insertData","setStart","setEnd","removeAllRanges","addRange"],"mappings":"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","sourcesContent":["/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\n\n/**\n * Browser dependencies\n */\n\nconst { TEXT_NODE, ELEMENT_NODE } = window.Node;\n\n/**\n * Creates a path as an array of indices from the given root node to the given\n * node.\n *\n * @param {Node}        node     Node to find the path of.\n * @param {HTMLElement} rootNode Root node to find the path from.\n * @param {Array}       path     Initial path to build on.\n *\n * @return {Array} The path from the root node to the node.\n */\nfunction createPathToNode( node, rootNode, path ) {\n\tconst parentNode = node.parentNode;\n\tlet i = 0;\n\n\twhile ( ( node = node.previousSibling ) ) {\n\t\ti++;\n\t}\n\n\tpath = [ i, ...path ];\n\n\tif ( parentNode !== rootNode ) {\n\t\tpath = createPathToNode( parentNode, rootNode, path );\n\t}\n\n\treturn path;\n}\n\n/**\n * Gets a node given a path (array of indices) from the given node.\n *\n * @param {HTMLElement} node Root node to find the wanted node in.\n * @param {Array}       path Path (indices) to the wanted node.\n *\n * @return {Object} Object with the found node and the remaining offset (if any).\n */\nfunction getNodeByPath( node, path ) {\n\tpath = [ ...path ];\n\n\twhile ( node && path.length > 1 ) {\n\t\tnode = node.childNodes[ path.shift() ];\n\t}\n\n\treturn {\n\t\tnode,\n\t\toffset: path[ 0 ],\n\t};\n}\n\nfunction createEmpty() {\n\tconst { body } = document.implementation.createHTMLDocument( '' );\n\treturn body;\n}\n\nfunction append( element, child ) {\n\tif ( typeof child === 'string' ) {\n\t\tchild = element.ownerDocument.createTextNode( child );\n\t}\n\n\tconst { type, attributes } = child;\n\n\tif ( type ) {\n\t\tchild = element.ownerDocument.createElement( type );\n\n\t\tfor ( const key in attributes ) {\n\t\t\tchild.setAttribute( key, attributes[ key ] );\n\t\t}\n\t}\n\n\treturn element.appendChild( child );\n}\n\nfunction appendText( node, text ) {\n\tnode.appendData( text );\n}\n\nfunction getLastChild( { lastChild } ) {\n\treturn lastChild;\n}\n\nfunction getParent( { parentNode } ) {\n\treturn parentNode;\n}\n\nfunction isText( { nodeType } ) {\n\treturn nodeType === TEXT_NODE;\n}\n\nfunction getText( { nodeValue } ) {\n\treturn nodeValue;\n}\n\nfunction remove( node ) {\n\treturn node.parentNode.removeChild( node );\n}\n\nfunction padEmptyLines( { element, createLinePadding, multilineWrapperTags } ) {\n\tconst length = element.childNodes.length;\n\tconst doc = element.ownerDocument;\n\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst child = element.childNodes[ index ];\n\n\t\tif ( child.nodeType === TEXT_NODE ) {\n\t\t\tif ( length === 1 && ! child.nodeValue ) {\n\t\t\t\t// Pad if the only child is an empty text node.\n\t\t\t\telement.appendChild( createLinePadding( doc ) );\n\t\t\t}\n\t\t} else {\n\t\t\tif (\n\t\t\t\tmultilineWrapperTags &&\n\t\t\t\t! child.previousSibling &&\n\t\t\t\tmultilineWrapperTags.indexOf( child.nodeName.toLowerCase() ) !== -1\n\t\t\t) {\n\t\t\t\t// Pad the line if there is no content before a nested wrapper.\n\t\t\t\telement.insertBefore( createLinePadding( doc ), child );\n\t\t\t}\n\n\t\t\tpadEmptyLines( { element: child, createLinePadding, multilineWrapperTags } );\n\t\t}\n\t}\n}\n\nfunction prepareFormats( prepareEditableTree = [], value ) {\n\treturn prepareEditableTree.reduce( ( accumlator, fn ) => {\n\t\treturn fn( accumlator, value.text );\n\t}, value.formats );\n}\n\nexport function toDom( {\n\tvalue,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\tcreateLinePadding,\n\tprepareEditableTree,\n} ) {\n\tlet startPath = [];\n\tlet endPath = [];\n\n\tconst tree = toTree( {\n\t\tvalue: {\n\t\t\t...value,\n\t\t\tformats: prepareFormats( prepareEditableTree, value ),\n\t\t},\n\t\tmultilineTag,\n\t\tmultilineWrapperTags,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t\tonStartIndex( body, pointer ) {\n\t\t\tstartPath = createPathToNode( pointer, body, [ pointer.nodeValue.length ] );\n\t\t},\n\t\tonEndIndex( body, pointer ) {\n\t\t\tendPath = createPathToNode( pointer, body, [ pointer.nodeValue.length ] );\n\t\t},\n\t\tisEditableTree: true,\n\t} );\n\n\tif ( createLinePadding ) {\n\t\tpadEmptyLines( { element: tree, createLinePadding, multilineWrapperTags } );\n\t}\n\n\treturn {\n\t\tbody: tree,\n\t\tselection: { startPath, endPath },\n\t};\n}\n\n/**\n * Create an `Element` tree from a Rich Text value and applies the difference to\n * the `Element` tree contained by `current`. If a `multilineTag` is provided,\n * text separated by two new lines will be wrapped in an `Element` of that type.\n *\n * @param {Object}      value        Value to apply.\n * @param {HTMLElement} current      The live root node to apply the element\n *                                   tree to.\n * @param {string}      multilineTag Multiline tag.\n */\nexport function apply( {\n\tvalue,\n\tcurrent,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\tcreateLinePadding,\n\tprepareEditableTree,\n} ) {\n\t// Construct a new element tree in memory.\n\tconst { body, selection } = toDom( {\n\t\tvalue,\n\t\tmultilineTag,\n\t\tmultilineWrapperTags,\n\t\tcreateLinePadding,\n\t\tprepareEditableTree,\n\t} );\n\n\tapplyValue( body, current );\n\n\tif ( value.start !== undefined ) {\n\t\tapplySelection( selection, current );\n\t}\n}\n\nexport function applyValue( future, current ) {\n\tlet i = 0;\n\n\twhile ( future.firstChild ) {\n\t\tconst currentChild = current.childNodes[ i ];\n\t\tconst futureNodeType = future.firstChild.nodeType;\n\n\t\tif ( ! currentChild ) {\n\t\t\tcurrent.appendChild( future.firstChild );\n\t\t} else if (\n\t\t\tfutureNodeType !== currentChild.nodeType ||\n\t\t\tfutureNodeType !== TEXT_NODE ||\n\t\t\tfuture.firstChild.nodeValue !== currentChild.nodeValue\n\t\t) {\n\t\t\tcurrent.replaceChild( future.firstChild, currentChild );\n\t\t} else {\n\t\t\tfuture.removeChild( future.firstChild );\n\t\t}\n\n\t\ti++;\n\t}\n\n\twhile ( current.childNodes[ i ] ) {\n\t\tcurrent.removeChild( current.childNodes[ i ] );\n\t}\n}\n\nexport function applySelection( selection, current ) {\n\tconst { node: startContainer, offset: startOffset } = getNodeByPath( current, selection.startPath );\n\tconst { node: endContainer, offset: endOffset } = getNodeByPath( current, selection.endPath );\n\n\tconst windowSelection = window.getSelection();\n\tconst range = current.ownerDocument.createRange();\n\tconst collapsed = startContainer === endContainer && startOffset === endOffset;\n\n\tif (\n\t\tcollapsed &&\n\t\tstartOffset === 0 &&\n\t\tstartContainer.previousSibling &&\n\t\tstartContainer.previousSibling.nodeType === ELEMENT_NODE &&\n\t\tstartContainer.previousSibling.nodeName !== 'BR'\n\t) {\n\t\tstartContainer.insertData( 0, '\\uFEFF' );\n\t\trange.setStart( startContainer, 1 );\n\t\trange.setEnd( endContainer, 1 );\n\t} else if (\n\t\tcollapsed &&\n\t\tstartOffset === 0 &&\n\t\tstartContainer === TEXT_NODE &&\n\t\tstartContainer.nodeValue.length === 0\n\t) {\n\t\tstartContainer.insertData( 0, '\\uFEFF' );\n\t\trange.setStart( startContainer, 1 );\n\t\trange.setEnd( endContainer, 1 );\n\t} else {\n\t\trange.setStart( startContainer, startOffset );\n\t\trange.setEnd( endContainer, endOffset );\n\t}\n\n\twindowSelection.removeAllRanges();\n\twindowSelection.addRange( range );\n}\n"]}