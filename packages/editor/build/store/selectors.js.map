{"version":3,"sources":["/home/circleci/project/packages/editor/src/store/selectors.js"],"names":["POST_UPDATE_TRANSACTION_ID","PERMALINK_POSTNAME_REGEX","INSERTER_UTILITY_HIGH","INSERTER_UTILITY_MEDIUM","INSERTER_UTILITY_LOW","INSERTER_UTILITY_NONE","MILLISECONDS_PER_HOUR","MILLISECONDS_PER_DAY","MILLISECONDS_PER_WEEK","ONE_MINUTE_IN_MS","EMPTY_ARRAY","hasEditorUndo","state","editor","past","length","hasEditorRedo","future","isEditedPostNew","getCurrentPost","status","hasChangedContent","present","blocks","isDirty","edits","isEditedPostDirty","Object","keys","inSomeHistory","isCleanNewPost","currentPost","getCurrentPostType","type","getCurrentPostId","id","getCurrentPostRevisionsCount","getCurrentPostLastRevisionId","getPostEdits","initialEdits","getReferenceByDistinctEdits","getCurrentPostAttribute","attributeName","post","hasOwnProperty","getEditedPostAttribute","getEditedPostContent","getAutosaveAttribute","hasAutosave","autosave","getAutosave","getEditedPostVisibility","password","isCurrentPostPending","isCurrentPostPublished","indexOf","Date","Number","date","isCurrentPostScheduled","isEditedPostPublishable","isEditedPostSaveable","isSavingPost","isEditedPostEmpty","getBlocksForSerialization","name","isEditedPostAutosaveable","some","field","isEditedPostBeingScheduled","checkedDate","isEditedPostDateFloating","modified","getBlockDependantsCacheBust","clientId","getBlockOrder","innerBlockClientId","getBlock","getBlockName","block","byClientId","attributes","result","value","key","source","getPostMeta","meta","innerBlocks","getBlocks","rootClientId","getClientIdsOfDescendants","clientIds","descendants","getClientIdsWithDescendants","topLevelIds","order","getGlobalBlockCount","blockName","count","getBlocksByClientId","getBlockCount","getBlockSelectionStart","blockSelection","start","getBlockSelectionEnd","end","getSelectedBlockCount","multiSelectedBlockCount","getMultiSelectedBlockClientIds","hasSelectedBlock","getSelectedBlockClientId","getSelectedBlock","getBlockRootClientId","getBlockHierarchyRootClientId","current","getAdjacentBlockClientId","startClientId","modifier","undefined","getFirstMultiSelectedBlockClientId","getLastMultiSelectedBlockClientId","orderSet","index","nextIndex","getPreviousBlockClientId","getNextBlockClientId","getSelectedBlocksInitialCaretPosition","initialPosition","blockOrder","startIndex","endIndex","slice","getMultiSelectedBlocks","multiSelectedBlockClientIds","map","isFirstMultiSelectedBlock","isBlockMultiSelected","isAncestorMultiSelected","ancestorClientId","isMultiSelected","getMultiSelectedBlocksStartClientId","getMultiSelectedBlocksEndClientId","getBlockIndex","isBlockSelected","hasSelectedInnerBlock","deep","innerClientId","isBlockWithinSelection","hasMultiSelection","isMultiSelecting","isSelectionEnabled","isEnabled","getBlockMode","blocksMode","isTyping","isCaretWithinFormattedText","getBlockInsertionPoint","insertionPoint","isBlockInsertionPointVisible","isValidTemplate","template","isValid","getTemplate","settings","getTemplateLock","templateLock","blockListSettings","getBlockListSettings","saving","requesting","didPostSaveRequestSucceed","successful","didPostSaveRequestFail","error","isAutosavingPost","isAutosave","getSuggestedPostFormat","isSingleUnmodifiedDefaultBlock","content","isSingleFreeformBlock","canInsertBlockType","checkAllowList","list","item","defaultResult","blockType","getEditorSettings","allowedBlockTypes","isBlockAllowedInEditor","isLocked","parentBlockListSettings","parentAllowedBlocks","hasParentAllowedBlock","blockAllowedParentBlocks","parent","parentName","hasBlockAllowedParent","getInsertUsage","preferences","insertUsage","getInserterItems","calculateUtility","category","isContextual","calculateFrecency","time","duration","now","shouldIncludeBlockType","buildBlockTypeInserterItem","isDisabled","initialAttributes","title","icon","keywords","utility","frecency","hasChildBlocksWithInserterSupport","shouldIncludeReusableBlock","reusableBlock","referencedBlock","referencedBlockType","buildReusableBlockInserterItem","ref","blockTypeInserterItems","filter","reusableBlockInserterItems","__experimentalGetReusableBlocks","reusableBlocks","data","__experimentalGetReusableBlock","isTemporary","isNaN","parseInt","__experimentalIsSavingReusableBlock","isSaving","__experimentalIsFetchingReusableBlock","isFetching","getStateBeforeOptimisticTransaction","transactionId","transaction","optimist","entry","beforeState","action","isPublishingPost","stateBeforeRequest","isPermalinkEditable","permalinkTemplate","test","getPermalink","getPermalinkParts","prefix","postName","suffix","split","predicate","getTokenSettings","tokens","isPostLocked","postLock","isPostSavingLocked","postSavingLock","isPostLockTakeover","isTakeover","getPostLockUser","user","getActivePostLock","activePostLock","canUserUseUnfilteredHTML","isPublishSidebarEnabled","PREFERENCES_DEFAULTS","getNotices","alternative","plugin","version","getReusableBlock","isSavingReusableBlock","hint","isFetchingReusableBlock","getReusableBlocks"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport {\n\tcastArray,\n\tflatMap,\n\tfind,\n\tfirst,\n\tget,\n\thas,\n\tincludes,\n\tisArray,\n\tisBoolean,\n\tlast,\n\tmap,\n\torderBy,\n\treduce,\n\tsize,\n\tsome,\n} from 'lodash';\nimport createSelector from 'rememo';\n\n/**\n * WordPress dependencies\n */\nimport {\n\tserialize,\n\tgetBlockType,\n\tgetBlockTypes,\n\thasBlockSupport,\n\thasChildBlocksWithInserterSupport,\n\tgetFreeformContentHandlerName,\n\tisUnmodifiedDefaultBlock,\n} from '@wordpress/blocks';\nimport { isInTheFuture, getDate } from '@wordpress/date';\nimport { removep } from '@wordpress/autop';\nimport { select } from '@wordpress/data';\nimport deprecated from '@wordpress/deprecated';\n\n/**\n * Dependencies\n */\nimport { PREFERENCES_DEFAULTS } from './defaults';\n\n/***\n * Module constants\n */\nexport const POST_UPDATE_TRANSACTION_ID = 'post-update';\nconst PERMALINK_POSTNAME_REGEX = /%(?:postname|pagename)%/;\nexport const INSERTER_UTILITY_HIGH = 3;\nexport const INSERTER_UTILITY_MEDIUM = 2;\nexport const INSERTER_UTILITY_LOW = 1;\nexport const INSERTER_UTILITY_NONE = 0;\nconst MILLISECONDS_PER_HOUR = 3600 * 1000;\nconst MILLISECONDS_PER_DAY = 24 * 3600 * 1000;\nconst MILLISECONDS_PER_WEEK = 7 * 24 * 3600 * 1000;\nconst ONE_MINUTE_IN_MS = 60 * 1000;\n\n/**\n * Shared reference to an empty array for cases where it is important to avoid\n * returning a new array reference on every invocation, as in a connected or\n * other pure component which performs `shouldComponentUpdate` check on props.\n * This should be used as a last resort, since the normalized data should be\n * maintained by the reducer result in state.\n *\n * @type {Array}\n */\nconst EMPTY_ARRAY = [];\n\n/**\n * Returns true if any past editor history snapshots exist, or false otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether undo history exists.\n */\nexport function hasEditorUndo( state ) {\n\treturn state.editor.past.length > 0;\n}\n\n/**\n * Returns true if any future editor history snapshots exist, or false\n * otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether redo history exists.\n */\nexport function hasEditorRedo( state ) {\n\treturn state.editor.future.length > 0;\n}\n\n/**\n * Returns true if the currently edited post is yet to be saved, or false if\n * the post has been saved.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post is new.\n */\nexport function isEditedPostNew( state ) {\n\treturn getCurrentPost( state ).status === 'auto-draft';\n}\n\n/**\n * Returns true if content includes unsaved changes, or false otherwise.\n *\n * @param {Object} state Editor state.\n *\n * @return {boolean} Whether content includes unsaved changes.\n */\nexport function hasChangedContent( state ) {\n\treturn (\n\t\tstate.editor.present.blocks.isDirty ||\n\n\t\t// `edits` is intended to contain only values which are different from\n\t\t// the saved post, so the mere presence of a property is an indicator\n\t\t// that the value is different than what is known to be saved. While\n\t\t// content in Visual mode is represented by the blocks state, in Text\n\t\t// mode it is tracked by `edits.content`.\n\t\t'content' in state.editor.present.edits\n\t);\n}\n\n/**\n * Returns true if there are unsaved values for the current edit session, or\n * false if the editing state matches the saved or new post.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether unsaved values exist.\n */\nexport function isEditedPostDirty( state ) {\n\tif ( hasChangedContent( state ) ) {\n\t\treturn true;\n\t}\n\n\t// Edits should contain only fields which differ from the saved post (reset\n\t// at initial load and save complete). Thus, a non-empty edits state can be\n\t// inferred to contain unsaved values.\n\tif ( Object.keys( state.editor.present.edits ).length > 0 ) {\n\t\treturn true;\n\t}\n\n\t// Edits and change detectiona are reset at the start of a save, but a post\n\t// is still considered dirty until the point at which the save completes.\n\t// Because the save is performed optimistically, the prior states are held\n\t// until committed. These can be referenced to determine whether there's a\n\t// chance that state may be reverted into one considered dirty.\n\treturn inSomeHistory( state, isEditedPostDirty );\n}\n\n/**\n * Returns true if there are no unsaved values for the current edit session and\n * if the currently edited post is new (has never been saved before).\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether new post and unsaved values exist.\n */\nexport function isCleanNewPost( state ) {\n\treturn ! isEditedPostDirty( state ) && isEditedPostNew( state );\n}\n\n/**\n * Returns the post currently being edited in its last known saved state, not\n * including unsaved edits. Returns an object containing relevant default post\n * values if the post has not yet been saved.\n *\n * @param {Object} state Global application state.\n *\n * @return {Object} Post object.\n */\nexport function getCurrentPost( state ) {\n\treturn state.currentPost;\n}\n\n/**\n * Returns the post type of the post currently being edited.\n *\n * @param {Object} state Global application state.\n *\n * @return {string} Post type.\n */\nexport function getCurrentPostType( state ) {\n\treturn state.currentPost.type;\n}\n\n/**\n * Returns the ID of the post currently being edited, or null if the post has\n * not yet been saved.\n *\n * @param {Object} state Global application state.\n *\n * @return {?number} ID of current post.\n */\nexport function getCurrentPostId( state ) {\n\treturn getCurrentPost( state ).id || null;\n}\n\n/**\n * Returns the number of revisions of the post currently being edited.\n *\n * @param {Object} state Global application state.\n *\n * @return {number} Number of revisions.\n */\nexport function getCurrentPostRevisionsCount( state ) {\n\treturn get( getCurrentPost( state ), [ '_links', 'version-history', 0, 'count' ], 0 );\n}\n\n/**\n * Returns the last revision ID of the post currently being edited,\n * or null if the post has no revisions.\n *\n * @param {Object} state Global application state.\n *\n * @return {?number} ID of the last revision.\n */\nexport function getCurrentPostLastRevisionId( state ) {\n\treturn get( getCurrentPost( state ), [ '_links', 'predecessor-version', 0, 'id' ], null );\n}\n\n/**\n * Returns any post values which have been changed in the editor but not yet\n * been saved.\n *\n * @param {Object} state Global application state.\n *\n * @return {Object} Object of key value pairs comprising unsaved edits.\n */\nexport const getPostEdits = createSelector(\n\t( state ) => {\n\t\treturn {\n\t\t\t...state.initialEdits,\n\t\t\t...state.editor.present.edits,\n\t\t};\n\t},\n\t( state ) => [\n\t\tstate.editor.present.edits,\n\t\tstate.initialEdits,\n\t]\n);\n\n/**\n * Returns a new reference when edited values have changed. This is useful in\n * inferring where an edit has been made between states by comparison of the\n * return values using strict equality.\n *\n * @example\n *\n * ```\n * const hasEditOccurred = (\n *    getReferenceByDistinctEdits( beforeState ) !==\n *    getReferenceByDistinctEdits( afterState )\n * );\n * ```\n *\n * @param {Object} state Editor state.\n *\n * @return {*} A value whose reference will change only when an edit occurs.\n */\nexport const getReferenceByDistinctEdits = createSelector(\n\t() => [],\n\t( state ) => [ state.editor ],\n);\n\n/**\n * Returns an attribute value of the saved post.\n *\n * @param {Object} state         Global application state.\n * @param {string} attributeName Post attribute name.\n *\n * @return {*} Post attribute value.\n */\nexport function getCurrentPostAttribute( state, attributeName ) {\n\tconst post = getCurrentPost( state );\n\tif ( post.hasOwnProperty( attributeName ) ) {\n\t\treturn post[ attributeName ];\n\t}\n}\n\n/**\n * Returns a single attribute of the post being edited, preferring the unsaved\n * edit if one exists, but falling back to the attribute for the last known\n * saved state of the post.\n *\n * @param {Object} state         Global application state.\n * @param {string} attributeName Post attribute name.\n *\n * @return {*} Post attribute value.\n */\nexport function getEditedPostAttribute( state, attributeName ) {\n\tconst edits = getPostEdits( state );\n\n\t// Special cases\n\tswitch ( attributeName ) {\n\t\tcase 'content':\n\t\t\treturn getEditedPostContent( state );\n\t}\n\n\tif ( ! edits.hasOwnProperty( attributeName ) ) {\n\t\treturn getCurrentPostAttribute( state, attributeName );\n\t}\n\n\treturn edits[ attributeName ];\n}\n\n/**\n * Returns an attribute value of the current autosave revision for a post, or\n * null if there is no autosave for the post.\n *\n * @param {Object} state         Global application state.\n * @param {string} attributeName Autosave attribute name.\n *\n * @return {*} Autosave attribute value.\n */\nexport function getAutosaveAttribute( state, attributeName ) {\n\tif ( ! hasAutosave( state ) ) {\n\t\treturn null;\n\t}\n\n\tconst autosave = getAutosave( state );\n\tif ( autosave.hasOwnProperty( attributeName ) ) {\n\t\treturn autosave[ attributeName ];\n\t}\n}\n\n/**\n * Returns the current visibility of the post being edited, preferring the\n * unsaved value if different than the saved post. The return value is one of\n * \"private\", \"password\", or \"public\".\n *\n * @param {Object} state Global application state.\n *\n * @return {string} Post visibility.\n */\nexport function getEditedPostVisibility( state ) {\n\tconst status = getEditedPostAttribute( state, 'status' );\n\tconst password = getEditedPostAttribute( state, 'password' );\n\n\tif ( status === 'private' ) {\n\t\treturn 'private';\n\t} else if ( password ) {\n\t\treturn 'password';\n\t}\n\treturn 'public';\n}\n\n/**\n * Returns true if post is pending review.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether current post is pending review.\n */\nexport function isCurrentPostPending( state ) {\n\treturn getCurrentPost( state ).status === 'pending';\n}\n\n/**\n * Return true if the current post has already been published.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post has been published.\n */\nexport function isCurrentPostPublished( state ) {\n\tconst post = getCurrentPost( state );\n\n\treturn [ 'publish', 'private' ].indexOf( post.status ) !== -1 ||\n\t\t( post.status === 'future' && ! isInTheFuture( new Date( Number( getDate( post.date ) ) - ONE_MINUTE_IN_MS ) ) );\n}\n\n/**\n * Returns true if post is already scheduled.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether current post is scheduled to be posted.\n */\nexport function isCurrentPostScheduled( state ) {\n\treturn getCurrentPost( state ).status === 'future' && ! isCurrentPostPublished( state );\n}\n\n/**\n * Return true if the post being edited can be published.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post can been published.\n */\nexport function isEditedPostPublishable( state ) {\n\tconst post = getCurrentPost( state );\n\n\t// TODO: Post being publishable should be superset of condition of post\n\t// being saveable. Currently this restriction is imposed at UI.\n\t//\n\t//  See: <PostPublishButton /> (`isButtonEnabled` assigned by `isSaveable`)\n\n\treturn isEditedPostDirty( state ) || [ 'publish', 'private', 'future' ].indexOf( post.status ) === -1;\n}\n\n/**\n * Returns true if the post can be saved, or false otherwise. A post must\n * contain a title, an excerpt, or non-empty content to be valid for save.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post can be saved.\n */\nexport function isEditedPostSaveable( state ) {\n\tif ( isSavingPost( state ) ) {\n\t\treturn false;\n\t}\n\n\t// TODO: Post should not be saveable if not dirty. Cannot be added here at\n\t// this time since posts where meta boxes are present can be saved even if\n\t// the post is not dirty. Currently this restriction is imposed at UI, but\n\t// should be moved here.\n\t//\n\t//  See: `isEditedPostPublishable` (includes `isEditedPostDirty` condition)\n\t//  See: <PostSavedState /> (`forceIsDirty` prop)\n\t//  See: <PostPublishButton /> (`forceIsDirty` prop)\n\t//  See: https://github.com/WordPress/gutenberg/pull/4184\n\n\treturn (\n\t\t!! getEditedPostAttribute( state, 'title' ) ||\n\t\t!! getEditedPostAttribute( state, 'excerpt' ) ||\n\t\t! isEditedPostEmpty( state )\n\t);\n}\n\n/**\n * Returns true if the edited post has content. A post has content if it has at\n * least one saveable block or otherwise has a non-empty content property\n * assigned.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether post has content.\n */\nexport function isEditedPostEmpty( state ) {\n\tconst blocks = getBlocksForSerialization( state );\n\n\t// While the condition of truthy content string is sufficient to determine\n\t// emptiness, testing saveable blocks length is a trivial operation. Since\n\t// this function can be called frequently, optimize for the fast case as a\n\t// condition of the mere existence of blocks. Note that the value of edited\n\t// content is used in place of blocks, thus allowed to fall through.\n\tif ( blocks.length && ! ( 'content' in getPostEdits( state ) ) ) {\n\t\t// Pierce the abstraction of the serializer in knowing that blocks are\n\t\t// joined with with newlines such that even if every individual block\n\t\t// produces an empty save result, the serialized content is non-empty.\n\t\tif ( blocks.length > 1 ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Freeform and unregistered blocks omit comment delimiters in their\n\t\t// output. The freeform block specifically may produce an empty string\n\t\t// to save. In the case of a single freeform block, fall through to the\n\t\t// full serialize. Otherwise, the single block is assumed non-empty by\n\t\t// virtue of its comment delimiters.\n\t\tif ( blocks[ 0 ].name !== getFreeformContentHandlerName() ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn ! getEditedPostContent( state );\n}\n\n/**\n * Returns true if the post can be autosaved, or false otherwise.\n *\n * @param  {Object}  state Global application state.\n *\n * @return {boolean} Whether the post can be autosaved.\n */\nexport function isEditedPostAutosaveable( state ) {\n\t// A post must contain a title, an excerpt, or non-empty content to be valid for autosaving.\n\tif ( ! isEditedPostSaveable( state ) ) {\n\t\treturn false;\n\t}\n\n\t// If we don't already have an autosave, the post is autosaveable.\n\tif ( ! hasAutosave( state ) ) {\n\t\treturn true;\n\t}\n\n\t// To avoid an expensive content serialization, use the content dirtiness\n\t// flag in place of content field comparison against the known autosave.\n\t// This is not strictly accurate, and relies on a tolerance toward autosave\n\t// request failures for unnecessary saves.\n\tif ( hasChangedContent( state ) ) {\n\t\treturn true;\n\t}\n\n\t// If the title, excerpt or content has changed, the post is autosaveable.\n\tconst autosave = getAutosave( state );\n\treturn [ 'title', 'excerpt' ].some( ( field ) => (\n\t\tautosave[ field ] !== getEditedPostAttribute( state, field )\n\t) );\n}\n\n/**\n * Returns the current autosave, or null if one is not set (i.e. if the post\n * has yet to be autosaved, or has been saved or published since the last\n * autosave).\n *\n * @param {Object} state Editor state.\n *\n * @return {?Object} Current autosave, if exists.\n */\nexport function getAutosave( state ) {\n\treturn state.autosave;\n}\n\n/**\n * Returns the true if there is an existing autosave, otherwise false.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether there is an existing autosave.\n */\nexport function hasAutosave( state ) {\n\treturn !! getAutosave( state );\n}\n\n/**\n * Return true if the post being edited is being scheduled. Preferring the\n * unsaved status values.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post has been published.\n */\nexport function isEditedPostBeingScheduled( state ) {\n\tconst date = getEditedPostAttribute( state, 'date' );\n\t// Offset the date by one minute (network latency)\n\tconst checkedDate = new Date( Number( getDate( date ) ) - ONE_MINUTE_IN_MS );\n\n\treturn isInTheFuture( checkedDate );\n}\n\n/**\n * Returns whether the current post should be considered to have a \"floating\"\n * date (i.e. that it would publish \"Immediately\" rather than at a set time).\n *\n * Unlike in the PHP backend, the REST API returns a full date string for posts\n * where the 0000-00-00T00:00:00 placeholder is present in the database. To\n * infer that a post is set to publish \"Immediately\" we check whether the date\n * and modified date are the same.\n *\n * @param  {Object}  state Editor state.\n *\n * @return {boolean} Whether the edited post has a floating date value.\n */\nexport function isEditedPostDateFloating( state ) {\n\tconst date = getEditedPostAttribute( state, 'date' );\n\tconst modified = getEditedPostAttribute( state, 'modified' );\n\tconst status = getEditedPostAttribute( state, 'status' );\n\tif ( status === 'draft' || status === 'auto-draft' ) {\n\t\treturn date === modified;\n\t}\n\treturn false;\n}\n\n/**\n * Returns a new reference when the inner blocks of a given block client ID\n * change. This is used exclusively as a memoized selector dependant, relying\n * on this selector's shared return value and recursively those of its inner\n * blocks defined as dependencies. This abuses mechanics of the selector\n * memoization to return from the original selector function only when\n * dependants change.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {*} A value whose reference will change only when inner blocks of\n *             the given block client ID change.\n */\nexport const getBlockDependantsCacheBust = createSelector(\n\t() => [],\n\t( state, clientId ) => map(\n\t\tgetBlockOrder( state, clientId ),\n\t\t( innerBlockClientId ) => getBlock( state, innerBlockClientId ),\n\t),\n);\n\n/**\n * Returns a block's name given its client ID, or null if no block exists with\n * the client ID.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {string} Block name.\n */\nexport function getBlockName( state, clientId ) {\n\tconst block = state.editor.present.blocks.byClientId[ clientId ];\n\treturn block ? block.name : null;\n}\n\n/**\n * Returns a block given its client ID. This is a parsed copy of the block,\n * containing its `blockName`, `clientId`, and current `attributes` state. This\n * is not the block's registration settings, which must be retrieved from the\n * blocks module registration store.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {Object} Parsed block object.\n */\nexport const getBlock = createSelector(\n\t( state, clientId ) => {\n\t\tconst block = state.editor.present.blocks.byClientId[ clientId ];\n\t\tif ( ! block ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet { attributes } = block;\n\n\t\t// Inject custom source attribute values.\n\t\t//\n\t\t// TODO: Create generic external sourcing pattern, not explicitly\n\t\t// targeting meta attributes.\n\t\tconst type = getBlockType( block.name );\n\t\tif ( type ) {\n\t\t\tattributes = reduce( type.attributes, ( result, value, key ) => {\n\t\t\t\tif ( value.source === 'meta' ) {\n\t\t\t\t\tif ( result === attributes ) {\n\t\t\t\t\t\tresult = { ...result };\n\t\t\t\t\t}\n\n\t\t\t\t\tresult[ key ] = getPostMeta( state, value.meta );\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}, attributes );\n\t\t}\n\n\t\treturn {\n\t\t\t...block,\n\t\t\tattributes,\n\t\t\tinnerBlocks: getBlocks( state, clientId ),\n\t\t};\n\t},\n\t( state, clientId ) => [\n\t\tstate.editor.present.blocks.byClientId[ clientId ],\n\t\tgetBlockDependantsCacheBust( state, clientId ),\n\t\tstate.editor.present.edits.meta,\n\t\tstate.initialEdits.meta,\n\t\tstate.currentPost.meta,\n\t]\n);\n\nfunction getPostMeta( state, key ) {\n\treturn has( state, [ 'editor', 'present', 'edits', 'meta', key ] ) ?\n\t\tget( state, [ 'editor', 'present', 'edits', 'meta', key ] ) :\n\t\tget( state, [ 'currentPost', 'meta', key ] );\n}\n\n/**\n * Returns all block objects for the current post being edited as an array in\n * the order they appear in the post.\n *\n * Note: It's important to memoize this selector to avoid return a new instance\n * on each call\n *\n * @param {Object}  state        Editor state.\n * @param {?String} rootClientId Optional root client ID of block list.\n *\n * @return {Object[]} Post blocks.\n */\nexport const getBlocks = createSelector(\n\t( state, rootClientId ) => {\n\t\treturn map(\n\t\t\tgetBlockOrder( state, rootClientId ),\n\t\t\t( clientId ) => getBlock( state, clientId )\n\t\t);\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks,\n\t]\n);\n\n/**\n * Returns an array containing the clientIds of all descendants\n * of the blocks given.\n *\n * @param {Object} state Global application state.\n * @param {Array} clientIds Array of blocks to inspect.\n *\n * @return {Array} ids of descendants.\n */\nexport const getClientIdsOfDescendants = ( state, clientIds ) => flatMap( clientIds, ( clientId ) => {\n\tconst descendants = getBlockOrder( state, clientId );\n\treturn [ ...descendants, ...getClientIdsOfDescendants( state, descendants ) ];\n} );\n\n/**\n * Returns an array containing the clientIds of the top-level blocks\n * and their descendants of any depth (for nested blocks).\n *\n * @param {Object} state Global application state.\n *\n * @return {Array} ids of top-level and descendant blocks.\n */\nexport const getClientIdsWithDescendants = createSelector(\n\t( state ) => {\n\t\tconst topLevelIds = getBlockOrder( state );\n\t\treturn [ ...topLevelIds, ...getClientIdsOfDescendants( state, topLevelIds ) ];\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks.order,\n\t]\n);\n\n/**\n * Returns the total number of blocks, or the total number of blocks with a specific name in a post.\n * The number returned includes nested blocks.\n *\n * @param {Object}  state     Global application state.\n * @param {?String} blockName Optional block name, if specified only blocks of that type will be counted.\n *\n * @return {number} Number of blocks in the post, or number of blocks with name equal to blockName.\n */\nexport const getGlobalBlockCount = createSelector(\n\t( state, blockName ) => {\n\t\tif ( ! blockName ) {\n\t\t\treturn size( state.editor.present.blocks.byClientId );\n\t\t}\n\t\treturn reduce(\n\t\t\tstate.editor.present.blocks.byClientId,\n\t\t\t( count, block ) => block.name === blockName ? count + 1 : count,\n\t\t\t0\n\t\t);\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks.byClientId,\n\t]\n);\n\n/**\n * Given an array of block client IDs, returns the corresponding array of block\n * objects.\n *\n * @param {Object}   state     Editor state.\n * @param {string[]} clientIds Client IDs for which blocks are to be returned.\n *\n * @return {WPBlock[]} Block objects.\n */\nexport const getBlocksByClientId = createSelector(\n\t( state, clientIds ) => map(\n\t\tcastArray( clientIds ),\n\t\t( clientId ) => getBlock( state, clientId )\n\t),\n\t( state ) => [\n\t\tstate.editor.present.edits.meta,\n\t\tstate.initialEdits.meta,\n\t\tstate.currentPost.meta,\n\t\tstate.editor.present.blocks,\n\t]\n);\n\n/**\n * Returns the number of blocks currently present in the post.\n *\n * @param {Object}  state        Editor state.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {number} Number of blocks in the post.\n */\nexport function getBlockCount( state, rootClientId ) {\n\treturn getBlockOrder( state, rootClientId ).length;\n}\n\n/**\n * Returns the current block selection start. This value may be null, and it\n * may represent either a singular block selection or multi-selection start.\n * A selection is singular if its start and end match.\n *\n * @param {Object} state Global application state.\n *\n * @return {?string} Client ID of block selection start.\n */\nexport function getBlockSelectionStart( state ) {\n\treturn state.blockSelection.start;\n}\n\n/**\n * Returns the current block selection end. This value may be null, and it\n * may represent either a singular block selection or multi-selection end.\n * A selection is singular if its start and end match.\n *\n * @param {Object} state Global application state.\n *\n * @return {?string} Client ID of block selection end.\n */\nexport function getBlockSelectionEnd( state ) {\n\treturn state.blockSelection.end;\n}\n\n/**\n * Returns the number of blocks currently selected in the post.\n *\n * @param {Object} state Global application state.\n *\n * @return {number} Number of blocks selected in the post.\n */\nexport function getSelectedBlockCount( state ) {\n\tconst multiSelectedBlockCount = getMultiSelectedBlockClientIds( state ).length;\n\n\tif ( multiSelectedBlockCount ) {\n\t\treturn multiSelectedBlockCount;\n\t}\n\n\treturn state.blockSelection.start ? 1 : 0;\n}\n\n/**\n * Returns true if there is a single selected block, or false otherwise.\n *\n * @param {Object} state Editor state.\n *\n * @return {boolean} Whether a single block is selected.\n */\nexport function hasSelectedBlock( state ) {\n\tconst { start, end } = state.blockSelection;\n\treturn !! start && start === end;\n}\n\n/**\n * Returns the currently selected block client ID, or null if there is no\n * selected block.\n *\n * @param {Object} state Editor state.\n *\n * @return {?string} Selected block client ID.\n */\nexport function getSelectedBlockClientId( state ) {\n\tconst { start, end } = state.blockSelection;\n\treturn start === end && start ? start : null;\n}\n\n/**\n * Returns the currently selected block, or null if there is no selected block.\n *\n * @param {Object} state Global application state.\n *\n * @return {?Object} Selected block.\n */\nexport function getSelectedBlock( state ) {\n\tconst clientId = getSelectedBlockClientId( state );\n\treturn clientId ? getBlock( state, clientId ) : null;\n}\n\n/**\n * Given a block client ID, returns the root block from which the block is\n * nested, an empty string for top-level blocks, or null if the block does not\n * exist.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block from which to find root client ID.\n *\n * @return {?string} Root client ID, if exists\n */\nexport const getBlockRootClientId = createSelector(\n\t( state, clientId ) => {\n\t\tconst { order } = state.editor.present.blocks;\n\n\t\tfor ( const rootClientId in order ) {\n\t\t\tif ( includes( order[ rootClientId ], clientId ) ) {\n\t\t\t\treturn rootClientId;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks.order,\n\t]\n);\n\n/**\n * Given a block client ID, returns the root of the hierarchy from which the block is nested, return the block itself for root level blocks.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block from which to find root client ID.\n *\n * @return {string} Root client ID\n */\nexport const getBlockHierarchyRootClientId = createSelector(\n\t( state, clientId ) => {\n\t\tlet rootClientId = clientId;\n\t\tlet current = clientId;\n\t\twhile ( rootClientId ) {\n\t\t\tcurrent = rootClientId;\n\t\t\trootClientId = getBlockRootClientId( state, current );\n\t\t}\n\n\t\treturn current;\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks.order,\n\t]\n);\n\n/**\n * Returns the client ID of the block adjacent one at the given reference\n * startClientId and modifier directionality. Defaults start startClientId to\n * the selected block, and direction as next block. Returns null if there is no\n * adjacent block.\n *\n * @param {Object}  state         Editor state.\n * @param {?string} startClientId Optional client ID of block from which to\n *                                search.\n * @param {?number} modifier      Directionality multiplier (1 next, -1\n *                                previous).\n *\n * @return {?string} Return the client ID of the block, or null if none exists.\n */\nexport function getAdjacentBlockClientId( state, startClientId, modifier = 1 ) {\n\t// Default to selected block.\n\tif ( startClientId === undefined ) {\n\t\tstartClientId = getSelectedBlockClientId( state );\n\t}\n\n\t// Try multi-selection starting at extent based on modifier.\n\tif ( startClientId === undefined ) {\n\t\tif ( modifier < 0 ) {\n\t\t\tstartClientId = getFirstMultiSelectedBlockClientId( state );\n\t\t} else {\n\t\t\tstartClientId = getLastMultiSelectedBlockClientId( state );\n\t\t}\n\t}\n\n\t// Validate working start client ID.\n\tif ( ! startClientId ) {\n\t\treturn null;\n\t}\n\n\t// Retrieve start block root client ID, being careful to allow the falsey\n\t// empty string top-level root by explicitly testing against null.\n\tconst rootClientId = getBlockRootClientId( state, startClientId );\n\tif ( rootClientId === null ) {\n\t\treturn null;\n\t}\n\n\tconst { order } = state.editor.present.blocks;\n\tconst orderSet = order[ rootClientId ];\n\tconst index = orderSet.indexOf( startClientId );\n\tconst nextIndex = ( index + ( 1 * modifier ) );\n\n\t// Block was first in set and we're attempting to get previous.\n\tif ( nextIndex < 0 ) {\n\t\treturn null;\n\t}\n\n\t// Block was last in set and we're attempting to get next.\n\tif ( nextIndex === orderSet.length ) {\n\t\treturn null;\n\t}\n\n\t// Assume incremented index is within the set.\n\treturn orderSet[ nextIndex ];\n}\n\n/**\n * Returns the previous block's client ID from the given reference start ID.\n * Defaults start to the selected block. Returns null if there is no previous\n * block.\n *\n * @param {Object}  state         Editor state.\n * @param {?string} startClientId Optional client ID of block from which to\n *                                search.\n *\n * @return {?string} Adjacent block's client ID, or null if none exists.\n */\nexport function getPreviousBlockClientId( state, startClientId ) {\n\treturn getAdjacentBlockClientId( state, startClientId, -1 );\n}\n\n/**\n * Returns the next block's client ID from the given reference start ID.\n * Defaults start to the selected block. Returns null if there is no next\n * block.\n *\n * @param {Object}  state         Editor state.\n * @param {?string} startClientId Optional client ID of block from which to\n *                                search.\n *\n * @return {?string} Adjacent block's client ID, or null if none exists.\n */\nexport function getNextBlockClientId( state, startClientId ) {\n\treturn getAdjacentBlockClientId( state, startClientId, 1 );\n}\n\n/**\n * Returns the initial caret position for the selected block.\n * This position is to used to position the caret properly when the selected block changes.\n *\n * @param {Object} state Global application state.\n *\n * @return {?Object} Selected block.\n */\nexport function getSelectedBlocksInitialCaretPosition( state ) {\n\tconst { start, end } = state.blockSelection;\n\tif ( start !== end || ! start ) {\n\t\treturn null;\n\t}\n\n\treturn state.blockSelection.initialPosition;\n}\n\n/**\n * Returns the current multi-selection set of block client IDs, or an empty\n * array if there is no multi-selection.\n *\n * @param {Object} state Editor state.\n *\n * @return {Array} Multi-selected block client IDs.\n */\nexport const getMultiSelectedBlockClientIds = createSelector(\n\t( state ) => {\n\t\tconst { start, end } = state.blockSelection;\n\t\tif ( start === end ) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Retrieve root client ID to aid in retrieving relevant nested block\n\t\t// order, being careful to allow the falsey empty string top-level root\n\t\t// by explicitly testing against null.\n\t\tconst rootClientId = getBlockRootClientId( state, start );\n\t\tif ( rootClientId === null ) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst blockOrder = getBlockOrder( state, rootClientId );\n\t\tconst startIndex = blockOrder.indexOf( start );\n\t\tconst endIndex = blockOrder.indexOf( end );\n\n\t\tif ( startIndex > endIndex ) {\n\t\t\treturn blockOrder.slice( endIndex, startIndex + 1 );\n\t\t}\n\n\t\treturn blockOrder.slice( startIndex, endIndex + 1 );\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks.order,\n\t\tstate.blockSelection.start,\n\t\tstate.blockSelection.end,\n\t],\n);\n\n/**\n * Returns the current multi-selection set of blocks, or an empty array if\n * there is no multi-selection.\n *\n * @param {Object} state Editor state.\n *\n * @return {Array} Multi-selected block objects.\n */\nexport const getMultiSelectedBlocks = createSelector(\n\t( state ) => {\n\t\tconst multiSelectedBlockClientIds = getMultiSelectedBlockClientIds( state );\n\t\tif ( ! multiSelectedBlockClientIds.length ) {\n\t\t\treturn EMPTY_ARRAY;\n\t\t}\n\n\t\treturn multiSelectedBlockClientIds.map( ( clientId ) => getBlock( state, clientId ) );\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks.order,\n\t\tstate.blockSelection.start,\n\t\tstate.blockSelection.end,\n\t\tstate.editor.present.blocks.byClientId,\n\t\tstate.editor.present.edits.meta,\n\t\tstate.initialEdits.meta,\n\t\tstate.currentPost.meta,\n\t]\n);\n\n/**\n * Returns the client ID of the first block in the multi-selection set, or null\n * if there is no multi-selection.\n *\n * @param {Object} state Editor state.\n *\n * @return {?string} First block client ID in the multi-selection set.\n */\nexport function getFirstMultiSelectedBlockClientId( state ) {\n\treturn first( getMultiSelectedBlockClientIds( state ) ) || null;\n}\n\n/**\n * Returns the client ID of the last block in the multi-selection set, or null\n * if there is no multi-selection.\n *\n * @param {Object} state Editor state.\n *\n * @return {?string} Last block client ID in the multi-selection set.\n */\nexport function getLastMultiSelectedBlockClientId( state ) {\n\treturn last( getMultiSelectedBlockClientIds( state ) ) || null;\n}\n\n/**\n * Returns true if a multi-selection exists, and the block corresponding to the\n * specified client ID is the first block of the multi-selection set, or false\n * otherwise.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {boolean} Whether block is first in multi-selection.\n */\nexport function isFirstMultiSelectedBlock( state, clientId ) {\n\treturn getFirstMultiSelectedBlockClientId( state ) === clientId;\n}\n\n/**\n * Returns true if the client ID occurs within the block multi-selection, or\n * false otherwise.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {boolean} Whether block is in multi-selection set.\n */\nexport function isBlockMultiSelected( state, clientId ) {\n\treturn getMultiSelectedBlockClientIds( state ).indexOf( clientId ) !== -1;\n}\n\n/**\n * Returns true if an ancestor of the block is multi-selected, or false\n * otherwise.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {boolean} Whether an ancestor of the block is in multi-selection\n *                   set.\n */\nexport const isAncestorMultiSelected = createSelector(\n\t( state, clientId ) => {\n\t\tlet ancestorClientId = clientId;\n\t\tlet isMultiSelected = false;\n\t\twhile ( ancestorClientId && ! isMultiSelected ) {\n\t\t\tancestorClientId = getBlockRootClientId( state, ancestorClientId );\n\t\t\tisMultiSelected = isBlockMultiSelected( state, ancestorClientId );\n\t\t}\n\t\treturn isMultiSelected;\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks.order,\n\t\tstate.blockSelection.start,\n\t\tstate.blockSelection.end,\n\t],\n);\n/**\n * Returns the client ID of the block which begins the multi-selection set, or\n * null if there is no multi-selection.\n *\n * This is not necessarily the first client ID in the selection.\n *\n * @see getFirstMultiSelectedBlockClientId\n *\n * @param {Object} state Editor state.\n *\n * @return {?string} Client ID of block beginning multi-selection.\n */\nexport function getMultiSelectedBlocksStartClientId( state ) {\n\tconst { start, end } = state.blockSelection;\n\tif ( start === end ) {\n\t\treturn null;\n\t}\n\treturn start || null;\n}\n\n/**\n * Returns the client ID of the block which ends the multi-selection set, or\n * null if there is no multi-selection.\n *\n * This is not necessarily the last client ID in the selection.\n *\n * @see getLastMultiSelectedBlockClientId\n *\n * @param {Object} state Editor state.\n *\n * @return {?string} Client ID of block ending multi-selection.\n */\nexport function getMultiSelectedBlocksEndClientId( state ) {\n\tconst { start, end } = state.blockSelection;\n\tif ( start === end ) {\n\t\treturn null;\n\t}\n\treturn end || null;\n}\n\n/**\n * Returns an array containing all block client IDs in the editor in the order\n * they appear. Optionally accepts a root client ID of the block list for which\n * the order should be returned, defaulting to the top-level block order.\n *\n * @param {Object}  state        Editor state.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {Array} Ordered client IDs of editor blocks.\n */\nexport function getBlockOrder( state, rootClientId ) {\n\treturn state.editor.present.blocks.order[ rootClientId || '' ] || EMPTY_ARRAY;\n}\n\n/**\n * Returns the index at which the block corresponding to the specified client\n * ID occurs within the block order, or `-1` if the block does not exist.\n *\n * @param {Object}  state        Editor state.\n * @param {string}  clientId     Block client ID.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {number} Index at which block exists in order.\n */\nexport function getBlockIndex( state, clientId, rootClientId ) {\n\treturn getBlockOrder( state, rootClientId ).indexOf( clientId );\n}\n\n/**\n * Returns true if the block corresponding to the specified client ID is\n * currently selected and no multi-selection exists, or false otherwise.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {boolean} Whether block is selected and multi-selection exists.\n */\nexport function isBlockSelected( state, clientId ) {\n\tconst { start, end } = state.blockSelection;\n\n\tif ( start !== end ) {\n\t\treturn false;\n\t}\n\n\treturn start === clientId;\n}\n\n/**\n * Returns true if one of the block's inner blocks is selected.\n *\n * @param {Object}  state    Editor state.\n * @param {string}  clientId Block client ID.\n * @param {boolean} deep     Perform a deep check.\n *\n * @return {boolean} Whether the block as an inner block selected\n */\nexport function hasSelectedInnerBlock( state, clientId, deep = false ) {\n\treturn some(\n\t\tgetBlockOrder( state, clientId ),\n\t\t( innerClientId ) => (\n\t\t\tisBlockSelected( state, innerClientId ) ||\n\t\t\tisBlockMultiSelected( state, innerClientId ) ||\n\t\t\t( deep && hasSelectedInnerBlock( state, innerClientId, deep ) )\n\t\t)\n\t);\n}\n\n/**\n * Returns true if the block corresponding to the specified client ID is\n * currently selected but isn't the last of the selected blocks. Here \"last\"\n * refers to the block sequence in the document, _not_ the sequence of\n * multi-selection, which is why `state.blockSelection.end` isn't used.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {boolean} Whether block is selected and not the last in the\n *                   selection.\n */\nexport function isBlockWithinSelection( state, clientId ) {\n\tif ( ! clientId ) {\n\t\treturn false;\n\t}\n\n\tconst clientIds = getMultiSelectedBlockClientIds( state );\n\tconst index = clientIds.indexOf( clientId );\n\treturn index > -1 && index < clientIds.length - 1;\n}\n\n/**\n * Returns true if a multi-selection has been made, or false otherwise.\n *\n * @param {Object} state Editor state.\n *\n * @return {boolean} Whether multi-selection has been made.\n */\nexport function hasMultiSelection( state ) {\n\tconst { start, end } = state.blockSelection;\n\treturn start !== end;\n}\n\n/**\n * Whether in the process of multi-selecting or not. This flag is only true\n * while the multi-selection is being selected (by mouse move), and is false\n * once the multi-selection has been settled.\n *\n * @see hasMultiSelection\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} True if multi-selecting, false if not.\n */\nexport function isMultiSelecting( state ) {\n\treturn state.blockSelection.isMultiSelecting;\n}\n\n/**\n * Selector that returns if multi-selection is enabled or not.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} True if it should be possible to multi-select blocks, false if multi-selection is disabled.\n */\nexport function isSelectionEnabled( state ) {\n\treturn state.blockSelection.isEnabled;\n}\n\n/**\n * Returns the block's editing mode, defaulting to \"visual\" if not explicitly\n * assigned.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {Object} Block editing mode.\n */\nexport function getBlockMode( state, clientId ) {\n\treturn state.blocksMode[ clientId ] || 'visual';\n}\n\n/**\n * Returns true if the user is typing, or false otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether user is typing.\n */\nexport function isTyping( state ) {\n\treturn state.isTyping;\n}\n\n/**\n * Returns true if the caret is within formatted text, or false otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the caret is within formatted text.\n */\nexport function isCaretWithinFormattedText( state ) {\n\treturn state.isCaretWithinFormattedText;\n}\n\n/**\n * Returns the insertion point, the index at which the new inserted block would\n * be placed. Defaults to the last index.\n *\n * @param {Object} state Editor state.\n *\n * @return {Object} Insertion point object with `rootClientId`, `index`.\n */\nexport function getBlockInsertionPoint( state ) {\n\tlet rootClientId, index;\n\n\tconst { insertionPoint, blockSelection } = state;\n\tif ( insertionPoint !== null ) {\n\t\treturn insertionPoint;\n\t}\n\n\tconst { end } = blockSelection;\n\tif ( end ) {\n\t\trootClientId = getBlockRootClientId( state, end ) || undefined;\n\t\tindex = getBlockIndex( state, end, rootClientId ) + 1;\n\t} else {\n\t\tindex = getBlockOrder( state ).length;\n\t}\n\n\treturn { rootClientId, index };\n}\n\n/**\n * Returns true if we should show the block insertion point.\n *\n * @param {Object} state Global application state.\n *\n * @return {?boolean} Whether the insertion point is visible or not.\n */\nexport function isBlockInsertionPointVisible( state ) {\n\treturn state.insertionPoint !== null;\n}\n\n/**\n * Returns whether the blocks matches the template or not.\n *\n * @param {boolean} state\n * @return {?boolean} Whether the template is valid or not.\n */\nexport function isValidTemplate( state ) {\n\treturn state.template.isValid;\n}\n\n/**\n * Returns the defined block template\n *\n * @param {boolean} state\n * @return {?Array}        Block Template\n */\nexport function getTemplate( state ) {\n\treturn state.settings.template;\n}\n\n/**\n * Returns the defined block template lock. Optionally accepts a root block\n * client ID as context, otherwise defaulting to the global context.\n *\n * @param {Object}  state        Editor state.\n * @param {?string} rootClientId Optional block root client ID.\n *\n * @return {?string} Block Template Lock\n */\nexport function getTemplateLock( state, rootClientId ) {\n\tif ( ! rootClientId ) {\n\t\treturn state.settings.templateLock;\n\t}\n\n\tconst blockListSettings = getBlockListSettings( state, rootClientId );\n\tif ( ! blockListSettings ) {\n\t\treturn null;\n\t}\n\n\treturn blockListSettings.templateLock;\n}\n\n/**\n * Returns true if the post is currently being saved, or false otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether post is being saved.\n */\nexport function isSavingPost( state ) {\n\treturn state.saving.requesting;\n}\n\n/**\n * Returns true if a previous post save was attempted successfully, or false\n * otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post was saved successfully.\n */\nexport function didPostSaveRequestSucceed( state ) {\n\treturn state.saving.successful;\n}\n\n/**\n * Returns true if a previous post save was attempted but failed, or false\n * otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post save failed.\n */\nexport function didPostSaveRequestFail( state ) {\n\treturn !! state.saving.error;\n}\n\n/**\n * Returns true if the post is autosaving, or false otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post is autosaving.\n */\nexport function isAutosavingPost( state ) {\n\treturn isSavingPost( state ) && state.saving.isAutosave;\n}\n\n/**\n * Returns a suggested post format for the current post, inferred only if there\n * is a single block within the post and it is of a type known to match a\n * default post format. Returns null if the format cannot be determined.\n *\n * @param {Object} state Global application state.\n *\n * @return {?string} Suggested post format.\n */\nexport function getSuggestedPostFormat( state ) {\n\tconst blocks = getBlockOrder( state );\n\n\tlet name;\n\t// If there is only one block in the content of the post grab its name\n\t// so we can derive a suitable post format from it.\n\tif ( blocks.length === 1 ) {\n\t\tname = getBlock( state, blocks[ 0 ] ).name;\n\t}\n\n\t// If there are two blocks in the content and the last one is a text blocks\n\t// grab the name of the first one to also suggest a post format from it.\n\tif ( blocks.length === 2 ) {\n\t\tif ( getBlock( state, blocks[ 1 ] ).name === 'core/paragraph' ) {\n\t\t\tname = getBlock( state, blocks[ 0 ] ).name;\n\t\t}\n\t}\n\n\t// We only convert to default post formats in core.\n\tswitch ( name ) {\n\t\tcase 'core/image':\n\t\t\treturn 'image';\n\t\tcase 'core/quote':\n\t\tcase 'core/pullquote':\n\t\t\treturn 'quote';\n\t\tcase 'core/gallery':\n\t\t\treturn 'gallery';\n\t\tcase 'core/video':\n\t\tcase 'core-embed/youtube':\n\t\tcase 'core-embed/vimeo':\n\t\t\treturn 'video';\n\t\tcase 'core/audio':\n\t\tcase 'core-embed/spotify':\n\t\tcase 'core-embed/soundcloud':\n\t\t\treturn 'audio';\n\t}\n\n\treturn null;\n}\n\n/**\n * Returns a set of blocks which are to be used in consideration of the post's\n * generated save content.\n *\n * @param {Object} state Editor state.\n *\n * @return {WPBlock[]} Filtered set of blocks for save.\n */\nexport function getBlocksForSerialization( state ) {\n\tconst blocks = getBlocks( state );\n\n\t// A single unmodified default block is assumed to be equivalent to an\n\t// empty post.\n\tconst isSingleUnmodifiedDefaultBlock = (\n\t\tblocks.length === 1 &&\n\t\tisUnmodifiedDefaultBlock( blocks[ 0 ] )\n\t);\n\n\tif ( isSingleUnmodifiedDefaultBlock ) {\n\t\treturn [];\n\t}\n\n\treturn blocks;\n}\n\n/**\n * Returns the content of the post being edited, preferring raw string edit\n * before falling back to serialization of block state.\n *\n * @param {Object} state Global application state.\n *\n * @return {string} Post content.\n */\nexport const getEditedPostContent = createSelector(\n\t( state ) => {\n\t\tconst edits = getPostEdits( state );\n\t\tif ( 'content' in edits ) {\n\t\t\treturn edits.content;\n\t\t}\n\n\t\tconst blocks = getBlocksForSerialization( state );\n\t\tconst content = serialize( blocks );\n\n\t\t// For compatibility purposes, treat a post consisting of a single\n\t\t// freeform block as legacy content and downgrade to a pre-block-editor\n\t\t// removep'd content format.\n\t\tconst isSingleFreeformBlock = (\n\t\t\tblocks.length === 1 &&\n\t\t\tblocks[ 0 ].name === getFreeformContentHandlerName()\n\t\t);\n\n\t\tif ( isSingleFreeformBlock ) {\n\t\t\treturn removep( content );\n\t\t}\n\n\t\treturn content;\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks,\n\t\tstate.editor.present.edits.content,\n\t\tstate.initialEdits.content,\n\t],\n);\n\n/**\n * Determines if the given block type is allowed to be inserted into the block list.\n *\n * @param {Object}  state        Editor state.\n * @param {string}  blockName    The name of the block type, e.g.' core/paragraph'.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {boolean} Whether the given block type is allowed to be inserted.\n */\nexport const canInsertBlockType = createSelector(\n\t( state, blockName, rootClientId = null ) => {\n\t\tconst checkAllowList = ( list, item, defaultResult = null ) => {\n\t\t\tif ( isBoolean( list ) ) {\n\t\t\t\treturn list;\n\t\t\t}\n\t\t\tif ( isArray( list ) ) {\n\t\t\t\treturn includes( list, item );\n\t\t\t}\n\t\t\treturn defaultResult;\n\t\t};\n\n\t\tconst blockType = getBlockType( blockName );\n\t\tif ( ! blockType ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { allowedBlockTypes } = getEditorSettings( state );\n\n\t\tconst isBlockAllowedInEditor = checkAllowList( allowedBlockTypes, blockName, true );\n\t\tif ( ! isBlockAllowedInEditor ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst isLocked = !! getTemplateLock( state, rootClientId );\n\t\tif ( isLocked ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst parentBlockListSettings = getBlockListSettings( state, rootClientId );\n\t\tconst parentAllowedBlocks = get( parentBlockListSettings, [ 'allowedBlocks' ] );\n\t\tconst hasParentAllowedBlock = checkAllowList( parentAllowedBlocks, blockName );\n\n\t\tconst blockAllowedParentBlocks = blockType.parent;\n\t\tconst parentName = getBlockName( state, rootClientId );\n\t\tconst hasBlockAllowedParent = checkAllowList( blockAllowedParentBlocks, parentName );\n\n\t\tif ( hasParentAllowedBlock !== null && hasBlockAllowedParent !== null ) {\n\t\t\treturn hasParentAllowedBlock || hasBlockAllowedParent;\n\t\t} else if ( hasParentAllowedBlock !== null ) {\n\t\t\treturn hasParentAllowedBlock;\n\t\t} else if ( hasBlockAllowedParent !== null ) {\n\t\t\treturn hasBlockAllowedParent;\n\t\t}\n\n\t\treturn true;\n\t},\n\t( state, blockName, rootClientId ) => [\n\t\tstate.blockListSettings[ rootClientId ],\n\t\tstate.editor.present.blocks.byClientId[ rootClientId ],\n\t\tstate.settings.allowedBlockTypes,\n\t\tstate.settings.templateLock,\n\t],\n);\n\n/**\n * Returns information about how recently and frequently a block has been inserted.\n *\n * @param {Object} state Global application state.\n * @param {string} id    A string which identifies the insert, e.g. 'core/block/12'\n *\n * @return {?{ time: number, count: number }} An object containing `time` which is when the last\n *                                            insert occured as a UNIX epoch, and `count` which is\n *                                            the number of inserts that have occurred.\n */\nfunction getInsertUsage( state, id ) {\n\treturn state.preferences.insertUsage[ id ] || null;\n}\n\n/**\n * Determines the items that appear in the inserter. Includes both static\n * items (e.g. a regular block type) and dynamic items (e.g. a reusable block).\n *\n * Each item object contains what's necessary to display a button in the\n * inserter and handle its selection.\n *\n * The 'utility' property indicates how useful we think an item will be to the\n * user. There are 4 levels of utility:\n *\n * 1. Blocks that are contextually useful (utility = 3)\n * 2. Blocks that have been previously inserted (utility = 2)\n * 3. Blocks that are in the common category (utility = 1)\n * 4. All other blocks (utility = 0)\n *\n * The 'frecency' property is a heuristic (https://en.wikipedia.org/wiki/Frecency)\n * that combines block usage frequenty and recency.\n *\n * Items are returned ordered descendingly by their 'utility' and 'frecency'.\n *\n * @param {Object}  state        Editor state.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {Editor.InserterItem[]} Items that appear in inserter.\n *\n * @typedef {Object} Editor.InserterItem\n * @property {string}   id                Unique identifier for the item.\n * @property {string}   name              The type of block to create.\n * @property {Object}   initialAttributes Attributes to pass to the newly created block.\n * @property {string}   title             Title of the item, as it appears in the inserter.\n * @property {string}   icon              Dashicon for the item, as it appears in the inserter.\n * @property {string}   category          Block category that the item is associated with.\n * @property {string[]} keywords          Keywords that can be searched to find this item.\n * @property {boolean}  isDisabled        Whether or not the user should be prevented from inserting\n *                                        this item.\n * @property {number}   utility           How useful we think this item is, between 0 and 3.\n * @property {number}   frecency          Hueristic that combines frequency and recency.\n */\nexport const getInserterItems = createSelector(\n\t( state, rootClientId = null ) => {\n\t\tconst calculateUtility = ( category, count, isContextual ) => {\n\t\t\tif ( isContextual ) {\n\t\t\t\treturn INSERTER_UTILITY_HIGH;\n\t\t\t} else if ( count > 0 ) {\n\t\t\t\treturn INSERTER_UTILITY_MEDIUM;\n\t\t\t} else if ( category === 'common' ) {\n\t\t\t\treturn INSERTER_UTILITY_LOW;\n\t\t\t}\n\t\t\treturn INSERTER_UTILITY_NONE;\n\t\t};\n\n\t\tconst calculateFrecency = ( time, count ) => {\n\t\t\tif ( ! time ) {\n\t\t\t\treturn count;\n\t\t\t}\n\n\t\t\t// The selector is cached, which means Date.now() is the last time that the\n\t\t\t// relevant state changed. This suits our needs.\n\t\t\tconst duration = Date.now() - time;\n\n\t\t\tswitch ( true ) {\n\t\t\t\tcase duration < MILLISECONDS_PER_HOUR:\n\t\t\t\t\treturn count * 4;\n\t\t\t\tcase duration < MILLISECONDS_PER_DAY:\n\t\t\t\t\treturn count * 2;\n\t\t\t\tcase duration < MILLISECONDS_PER_WEEK:\n\t\t\t\t\treturn count / 2;\n\t\t\t\tdefault:\n\t\t\t\t\treturn count / 4;\n\t\t\t}\n\t\t};\n\n\t\tconst shouldIncludeBlockType = ( blockType ) => {\n\t\t\tif ( ! hasBlockSupport( blockType, 'inserter', true ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn canInsertBlockType( state, blockType.name, rootClientId );\n\t\t};\n\n\t\tconst buildBlockTypeInserterItem = ( blockType ) => {\n\t\t\tconst id = blockType.name;\n\n\t\t\tlet isDisabled = false;\n\t\t\tif ( ! hasBlockSupport( blockType.name, 'multiple', true ) ) {\n\t\t\t\tisDisabled = some( getBlocksByClientId( state, getClientIdsWithDescendants( state ) ), { name: blockType.name } );\n\t\t\t}\n\n\t\t\tconst isContextual = isArray( blockType.parent );\n\t\t\tconst { time, count = 0 } = getInsertUsage( state, id ) || {};\n\n\t\t\treturn {\n\t\t\t\tid,\n\t\t\t\tname: blockType.name,\n\t\t\t\tinitialAttributes: {},\n\t\t\t\ttitle: blockType.title,\n\t\t\t\ticon: blockType.icon,\n\t\t\t\tcategory: blockType.category,\n\t\t\t\tkeywords: blockType.keywords,\n\t\t\t\tisDisabled,\n\t\t\t\tutility: calculateUtility( blockType.category, count, isContextual ),\n\t\t\t\tfrecency: calculateFrecency( time, count ),\n\t\t\t\thasChildBlocksWithInserterSupport: hasChildBlocksWithInserterSupport( blockType.name ),\n\t\t\t};\n\t\t};\n\n\t\tconst shouldIncludeReusableBlock = ( reusableBlock ) => {\n\t\t\tif ( ! canInsertBlockType( state, 'core/block', rootClientId ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst referencedBlock = getBlock( state, reusableBlock.clientId );\n\t\t\tif ( ! referencedBlock ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst referencedBlockType = getBlockType( referencedBlock.name );\n\t\t\tif ( ! referencedBlockType ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif ( ! canInsertBlockType( state, referencedBlockType.name, rootClientId ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t};\n\n\t\tconst buildReusableBlockInserterItem = ( reusableBlock ) => {\n\t\t\tconst id = `core/block/${ reusableBlock.id }`;\n\n\t\t\tconst referencedBlock = getBlock( state, reusableBlock.clientId );\n\t\t\tconst referencedBlockType = getBlockType( referencedBlock.name );\n\n\t\t\tconst { time, count = 0 } = getInsertUsage( state, id ) || {};\n\t\t\tconst utility = calculateUtility( 'reusable', count, false );\n\t\t\tconst frecency = calculateFrecency( time, count );\n\n\t\t\treturn {\n\t\t\t\tid,\n\t\t\t\tname: 'core/block',\n\t\t\t\tinitialAttributes: { ref: reusableBlock.id },\n\t\t\t\ttitle: reusableBlock.title,\n\t\t\t\ticon: referencedBlockType.icon,\n\t\t\t\tcategory: 'reusable',\n\t\t\t\tkeywords: [],\n\t\t\t\tisDisabled: false,\n\t\t\t\tutility,\n\t\t\t\tfrecency,\n\t\t\t};\n\t\t};\n\n\t\tconst blockTypeInserterItems = getBlockTypes()\n\t\t\t.filter( shouldIncludeBlockType )\n\t\t\t.map( buildBlockTypeInserterItem );\n\n\t\tconst reusableBlockInserterItems = __experimentalGetReusableBlocks( state )\n\t\t\t.filter( shouldIncludeReusableBlock )\n\t\t\t.map( buildReusableBlockInserterItem );\n\n\t\treturn orderBy(\n\t\t\t[ ...blockTypeInserterItems, ...reusableBlockInserterItems ],\n\t\t\t[ 'utility', 'frecency' ],\n\t\t\t[ 'desc', 'desc' ]\n\t\t);\n\t},\n\t( state, rootClientId ) => [\n\t\tstate.blockListSettings[ rootClientId ],\n\t\tstate.editor.present.blocks,\n\t\tstate.preferences.insertUsage,\n\t\tstate.settings.allowedBlockTypes,\n\t\tstate.settings.templateLock,\n\t\tstate.reusableBlocks.data,\n\t\tgetBlockTypes(),\n\t],\n);\n\n/**\n * Returns the reusable block with the given ID.\n *\n * @param {Object}        state Global application state.\n * @param {number|string} ref   The reusable block's ID.\n *\n * @return {Object} The reusable block, or null if none exists.\n */\nexport const __experimentalGetReusableBlock = createSelector(\n\t( state, ref ) => {\n\t\tconst block = state.reusableBlocks.data[ ref ];\n\t\tif ( ! block ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst isTemporary = isNaN( parseInt( ref ) );\n\n\t\treturn {\n\t\t\t...block,\n\t\t\tid: isTemporary ? ref : +ref,\n\t\t\tisTemporary,\n\t\t};\n\t},\n\t( state, ref ) => [\n\t\tstate.reusableBlocks.data[ ref ],\n\t],\n);\n\n/**\n * Returns whether or not the reusable block with the given ID is being saved.\n *\n * @param {Object} state Global application state.\n * @param {string} ref   The reusable block's ID.\n *\n * @return {boolean} Whether or not the reusable block is being saved.\n */\nexport function __experimentalIsSavingReusableBlock( state, ref ) {\n\treturn state.reusableBlocks.isSaving[ ref ] || false;\n}\n\n/**\n * Returns true if the reusable block with the given ID is being fetched, or\n * false otherwise.\n *\n * @param {Object} state Global application state.\n * @param {string} ref   The reusable block's ID.\n *\n * @return {boolean} Whether the reusable block is being fetched.\n */\nexport function __experimentalIsFetchingReusableBlock( state, ref ) {\n\treturn !! state.reusableBlocks.isFetching[ ref ];\n}\n\n/**\n * Returns an array of all reusable blocks.\n *\n * @param {Object} state Global application state.\n *\n * @return {Array} An array of all reusable blocks.\n */\nexport function __experimentalGetReusableBlocks( state ) {\n\treturn map(\n\t\tstate.reusableBlocks.data,\n\t\t( value, ref ) => __experimentalGetReusableBlock( state, ref )\n\t);\n}\n\n/**\n * Returns state object prior to a specified optimist transaction ID, or `null`\n * if the transaction corresponding to the given ID cannot be found.\n *\n * @param {Object} state         Current global application state.\n * @param {Object} transactionId Optimist transaction ID.\n *\n * @return {Object} Global application state prior to transaction.\n */\nexport function getStateBeforeOptimisticTransaction( state, transactionId ) {\n\tconst transaction = find( state.optimist, ( entry ) => (\n\t\tentry.beforeState &&\n\t\tget( entry.action, [ 'optimist', 'id' ] ) === transactionId\n\t) );\n\n\treturn transaction ? transaction.beforeState : null;\n}\n\n/**\n * Returns true if the post is being published, or false otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether post is being published.\n */\nexport function isPublishingPost( state ) {\n\tif ( ! isSavingPost( state ) ) {\n\t\treturn false;\n\t}\n\n\t// Saving is optimistic, so assume that current post would be marked as\n\t// published if publishing\n\tif ( ! isCurrentPostPublished( state ) ) {\n\t\treturn false;\n\t}\n\n\t// Use post update transaction ID to retrieve the state prior to the\n\t// optimistic transaction\n\tconst stateBeforeRequest = getStateBeforeOptimisticTransaction(\n\t\tstate,\n\t\tPOST_UPDATE_TRANSACTION_ID\n\t);\n\n\t// Consider as publishing when current post prior to request was not\n\t// considered published\n\treturn !! stateBeforeRequest && ! isCurrentPostPublished( stateBeforeRequest );\n}\n\n/**\n * Returns whether the permalink is editable or not.\n *\n * @param {Object} state Editor state.\n *\n * @return {boolean} Whether or not the permalink is editable.\n */\nexport function isPermalinkEditable( state ) {\n\tconst permalinkTemplate = getEditedPostAttribute( state, 'permalink_template' );\n\n\treturn PERMALINK_POSTNAME_REGEX.test( permalinkTemplate );\n}\n\n/**\n * Returns the permalink for the post.\n *\n * @param {Object} state Editor state.\n *\n * @return {string} The permalink.\n */\nexport function getPermalink( state ) {\n\tconst { prefix, postName, suffix } = getPermalinkParts( state );\n\n\tif ( isPermalinkEditable( state ) ) {\n\t\treturn prefix + postName + suffix;\n\t}\n\n\treturn prefix;\n}\n\n/**\n * Returns the permalink for a post, split into it's three parts: the prefix, the postName, and the suffix.\n *\n * @param {Object} state Editor state.\n *\n * @return {Object} The prefix, postName, and suffix for the permalink.\n */\nexport function getPermalinkParts( state ) {\n\tconst permalinkTemplate = getEditedPostAttribute( state, 'permalink_template' );\n\tconst postName = getEditedPostAttribute( state, 'slug' ) || getEditedPostAttribute( state, 'generated_slug' );\n\n\tconst [ prefix, suffix ] = permalinkTemplate.split( PERMALINK_POSTNAME_REGEX );\n\n\treturn {\n\t\tprefix,\n\t\tpostName,\n\t\tsuffix,\n\t};\n}\n\n/**\n * Returns true if an optimistic transaction is pending commit, for which the\n * before state satisfies the given predicate function.\n *\n * @param {Object}   state     Editor state.\n * @param {Function} predicate Function given state, returning true if match.\n *\n * @return {boolean} Whether predicate matches for some history.\n */\nexport function inSomeHistory( state, predicate ) {\n\tconst { optimist } = state;\n\n\t// In recursion, optimist state won't exist. Assume exhausted options.\n\tif ( ! optimist ) {\n\t\treturn false;\n\t}\n\n\treturn optimist.some( ( { beforeState } ) => (\n\t\tbeforeState && predicate( beforeState )\n\t) );\n}\n\n/**\n * Returns the Block List settings of a block, if any exist.\n *\n * @param {Object}  state    Editor state.\n * @param {?string} clientId Block client ID.\n *\n * @return {?Object} Block settings of the block if set.\n */\nexport function getBlockListSettings( state, clientId ) {\n\treturn state.blockListSettings[ clientId ];\n}\n\n/**\n * Returns the editor settings.\n *\n * @param {Object} state Editor state.\n *\n * @return {Object} The editor settings object.\n */\nexport function getEditorSettings( state ) {\n\treturn state.settings;\n}\n\n/**\n * Returns the token settings.\n *\n * @param {Object} state Editor state.\n * @param {?string} name Token name.\n *\n * @return {Object} Token settings object, or the named token settings object if set.\n */\nexport function getTokenSettings( state, name ) {\n\tif ( ! name ) {\n\t\treturn state.tokens;\n\t}\n\n\treturn state.tokens[ name ];\n}\n\n/**\n * Returns whether the post is locked.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Is locked.\n */\nexport function isPostLocked( state ) {\n\treturn state.postLock.isLocked;\n}\n\n/**\n * Returns whether post saving is locked.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Is locked.\n */\nexport function isPostSavingLocked( state ) {\n\treturn Object.keys( state.postSavingLock ).length > 0;\n}\n\n/**\n * Returns whether the edition of the post has been taken over.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Is post lock takeover.\n */\nexport function isPostLockTakeover( state ) {\n\treturn state.postLock.isTakeover;\n}\n\n/**\n * Returns details about the post lock user.\n *\n * @param {Object} state Global application state.\n *\n * @return {Object} A user object.\n */\nexport function getPostLockUser( state ) {\n\treturn state.postLock.user;\n}\n\n/**\n * Returns the active post lock.\n *\n * @param {Object} state Global application state.\n *\n * @return {Object} The lock object.\n */\nexport function getActivePostLock( state ) {\n\treturn state.postLock.activePostLock;\n}\n\n/**\n * Returns whether or not the user has the unfiltered_html capability.\n *\n * @param {Object} state Editor state.\n *\n * @return {boolean} Whether the user can or can't post unfiltered HTML.\n */\nexport function canUserUseUnfilteredHTML( state ) {\n\treturn has( getCurrentPost( state ), [ '_links', 'wp:action-unfiltered-html' ] );\n}\n\n/**\n * Returns whether the pre-publish panel should be shown\n * or skipped when the user clicks the \"publish\" button.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the pre-publish panel should be shown or not.\n */\nexport function isPublishSidebarEnabled( state ) {\n\tif ( state.preferences.hasOwnProperty( 'isPublishSidebarEnabled' ) ) {\n\t\treturn state.preferences.isPublishSidebarEnabled;\n\t}\n\treturn PREFERENCES_DEFAULTS.isPublishSidebarEnabled;\n}\n\n//\n// Deprecated\n//\n\nexport function getNotices() {\n\tdeprecated( 'getNotices selector (`core/editor` store)', {\n\t\talternative: 'getNotices selector (`core/notices` store)',\n\t\tplugin: 'Gutenberg',\n\t\tversion: '4.4.0',\n\t} );\n\n\treturn select( 'core/notices' ).getNotices();\n}\n\nexport function getReusableBlock( state, ref ) {\n\tdeprecated( \"wp.data.select( 'core/editor' ).getReusableBlock( ref )\", {\n\t\talternative: \"wp.data.select( 'core' ).getEntityRecord( 'postType', 'wp_block', ref )\",\n\t\tplugin: 'Gutenberg',\n\t\tversion: '4.4.0',\n\t} );\n\n\treturn __experimentalGetReusableBlock( state, ref );\n}\n\nexport function isSavingReusableBlock( state, ref ) {\n\tdeprecated( 'isSavingReusableBlock selector (`core/editor` store)', {\n\t\talternative: '__experimentalIsSavingReusableBlock selector (`core/edtior` store)',\n\t\tplugin: 'Gutenberg',\n\t\tversion: '4.4.0',\n\t\thint: 'Using experimental APIs is strongly discouraged as they are subject to removal without notice.',\n\t} );\n\n\treturn __experimentalIsSavingReusableBlock( state, ref );\n}\n\nexport function isFetchingReusableBlock( state, ref ) {\n\tdeprecated( \"wp.data.select( 'core/editor' ).isFetchingReusableBlock( ref )\", {\n\t\talternative: \"wp.data.select( 'core' ).isResolving( 'getEntityRecord', 'wp_block', ref )\",\n\t\tplugin: 'Gutenberg',\n\t\tversion: '4.4.0',\n\t} );\n\n\treturn __experimentalIsFetchingReusableBlock( state, ref );\n}\n\nexport function getReusableBlocks( state ) {\n\tdeprecated( \"wp.data.select( 'core/editor' ).getReusableBlocks( ref )\", {\n\t\talternative: \"wp.data.select( 'core' ).getEntityRecords( 'postType', 'wp_block' )\",\n\t\tplugin: 'Gutenberg',\n\t\tversion: '4.4.0',\n\t} );\n\n\treturn __experimentalGetReusableBlocks( state );\n}\n"]}