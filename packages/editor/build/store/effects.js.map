{"version":3,"sources":["/home/circleci/project/packages/editor/src/store/effects.js"],"names":["validateBlocksToTemplate","action","store","state","getState","template","templateLock","isBlocksValidToTemplate","blocks","selectPreviousBlock","selectPrevious","firstRemovedBlockClientId","clientIds","currentSelectedBlock","previousState","editor","present","past","rootClientId","blockClientIdToSelect","ensureDefaultBlock","REQUEST_POST_UPDATE","REQUEST_POST_UPDATE_SUCCESS","requestPostUpdateSuccess","REQUEST_POST_UPDATE_FAILURE","requestPostUpdateFailure","TRASH_POST","TRASH_POST_FAILURE","trashPostFailure","REFRESH_POST","MERGE_BLOCKS","dispatch","firstBlockClientId","secondBlockClientId","blockA","blockB","blockType","name","merge","clientId","blocksWithTheSameType","length","updatedAttributes","attributes","slice","SETUP_EDITOR","post","edits","content","raw","isNewPost","status","setupAction","RESET_BLOCKS","SYNCHRONIZE_TEMPLATE","updatedBlockList","FETCH_REUSABLE_BLOCKS","SAVE_REUSABLE_BLOCK","DELETE_REUSABLE_BLOCK","RECEIVE_REUSABLE_BLOCKS","receiveReusableBlocks","CONVERT_BLOCK_TO_STATIC","convertBlockToStatic","CONVERT_BLOCK_TO_REUSABLE","convertBlockToReusable","REMOVE_BLOCKS","REPLACE_BLOCKS","MULTI_SELECT","blockCount"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { compact, last, has } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { speak } from '@wordpress/a11y';\nimport {\n\tparse,\n\tgetBlockType,\n\tswitchToBlockType,\n\tdoBlocksMatchTemplate,\n\tsynchronizeBlocksWithTemplate,\n} from '@wordpress/blocks';\nimport { __, sprintf } from '@wordpress/i18n';\n\n/**\n * Internal dependencies\n */\nimport {\n\tsetupEditorState,\n\treplaceBlocks,\n\tselectBlock,\n\tresetBlocks,\n\tsetTemplateValidity,\n\tinsertDefaultBlock,\n} from './actions';\nimport {\n\tgetBlock,\n\tgetBlockRootClientId,\n\tgetBlocks,\n\tgetBlockCount,\n\tgetPreviousBlockClientId,\n\tgetSelectedBlock,\n\tgetSelectedBlockCount,\n\tgetTemplate,\n\tgetTemplateLock,\n\tisValidTemplate,\n} from './selectors';\nimport {\n\tfetchReusableBlocks,\n\tsaveReusableBlocks,\n\tdeleteReusableBlocks,\n\tconvertBlockToReusable,\n\tconvertBlockToStatic,\n\treceiveReusableBlocks,\n} from './effects/reusable-blocks';\nimport {\n\trequestPostUpdate,\n\trequestPostUpdateSuccess,\n\trequestPostUpdateFailure,\n\ttrashPost,\n\ttrashPostFailure,\n\trefreshPost,\n} from './effects/posts';\n\n/**\n * Block validity is a function of blocks state (at the point of a\n * reset) and the template setting. As a compromise to its placement\n * across distinct parts of state, it is implemented here as a side-\n * effect of the block reset action.\n *\n * @param {Object} action RESET_BLOCKS action.\n * @param {Object} store  Store instance.\n *\n * @return {?Object} New validity set action if validity has changed.\n */\nexport function validateBlocksToTemplate( action, store ) {\n\tconst state = store.getState();\n\tconst template = getTemplate( state );\n\tconst templateLock = getTemplateLock( state );\n\n\t// Unlocked templates are considered always valid because they act\n\t// as default values only.\n\tconst isBlocksValidToTemplate = (\n\t\t! template ||\n\t\ttemplateLock !== 'all' ||\n\t\tdoBlocksMatchTemplate( action.blocks, template )\n\t);\n\n\t// Update if validity has changed.\n\tif ( isBlocksValidToTemplate !== isValidTemplate( state ) ) {\n\t\treturn setTemplateValidity( isBlocksValidToTemplate );\n\t}\n}\n\n/**\n * Effect handler which will return a block select action to select the block\n * occurring before the selected block in the previous state, unless it is the\n * same block or the action includes a falsey `selectPrevious` option flag.\n *\n * @param {Object} action Action which had initiated the effect handler.\n * @param {Object} store  Store instance.\n *\n * @return {?Object} Block select action to select previous, if applicable.\n */\nexport function selectPreviousBlock( action, store ) {\n\t// if the action says previous block should not be selected don't do anything.\n\tif ( ! action.selectPrevious ) {\n\t\treturn;\n\t}\n\n\tconst firstRemovedBlockClientId = action.clientIds[ 0 ];\n\tconst state = store.getState();\n\tconst currentSelectedBlock = getSelectedBlock( state );\n\n\t// recreate the state before the block was removed.\n\tconst previousState = { ...state, editor: { present: last( state.editor.past ) } };\n\n\t// rootClientId of the removed block.\n\tconst rootClientId = getBlockRootClientId( previousState, firstRemovedBlockClientId );\n\n\t// Client ID of the block that was before the removed block or the\n\t// rootClientId if the removed block was first amongst its siblings.\n\tconst blockClientIdToSelect = getPreviousBlockClientId( previousState, firstRemovedBlockClientId ) || rootClientId;\n\n\t// Dispatch select block action if the currently selected block\n\t// is not already the block we want to be selected.\n\tif ( blockClientIdToSelect !== currentSelectedBlock ) {\n\t\treturn selectBlock( blockClientIdToSelect, -1 );\n\t}\n}\n\n/**\n * Effect handler which will return a default block insertion action if there\n * are no other blocks at the root of the editor. This is expected to be used\n * in actions which may result in no blocks remaining in the editor (removal,\n * replacement, etc).\n *\n * @param {Object} action Action which had initiated the effect handler.\n * @param {Object} store  Store instance.\n *\n * @return {?Object} Default block insert action, if no other blocks exist.\n */\nexport function ensureDefaultBlock( action, store ) {\n\tif ( ! getBlockCount( store.getState() ) ) {\n\t\treturn insertDefaultBlock();\n\t}\n}\n\nexport default {\n\tREQUEST_POST_UPDATE: ( action, store ) => {\n\t\trequestPostUpdate( action, store );\n\t},\n\tREQUEST_POST_UPDATE_SUCCESS: requestPostUpdateSuccess,\n\tREQUEST_POST_UPDATE_FAILURE: requestPostUpdateFailure,\n\tTRASH_POST: ( action, store ) => {\n\t\ttrashPost( action, store );\n\t},\n\tTRASH_POST_FAILURE: trashPostFailure,\n\tREFRESH_POST: ( action, store ) => {\n\t\trefreshPost( action, store );\n\t},\n\tMERGE_BLOCKS( action, store ) {\n\t\tconst { dispatch } = store;\n\t\tconst state = store.getState();\n\t\tconst [ firstBlockClientId, secondBlockClientId ] = action.blocks;\n\t\tconst blockA = getBlock( state, firstBlockClientId );\n\t\tconst blockB = getBlock( state, secondBlockClientId );\n\t\tconst blockType = getBlockType( blockA.name );\n\n\t\t// Only focus the previous block if it's not mergeable\n\t\tif ( ! blockType.merge ) {\n\t\t\tdispatch( selectBlock( blockA.clientId ) );\n\t\t\treturn;\n\t\t}\n\n\t\t// We can only merge blocks with similar types\n\t\t// thus, we transform the block to merge first\n\t\tconst blocksWithTheSameType = blockA.name === blockB.name ?\n\t\t\t[ blockB ] :\n\t\t\tswitchToBlockType( blockB, blockA.name );\n\n\t\t// If the block types can not match, do nothing\n\t\tif ( ! blocksWithTheSameType || ! blocksWithTheSameType.length ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Calling the merge to update the attributes and remove the block to be merged\n\t\tconst updatedAttributes = blockType.merge(\n\t\t\tblockA.attributes,\n\t\t\tblocksWithTheSameType[ 0 ].attributes\n\t\t);\n\n\t\tdispatch( selectBlock( blockA.clientId, -1 ) );\n\t\tdispatch( replaceBlocks(\n\t\t\t[ blockA.clientId, blockB.clientId ],\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t...blockA,\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\t...blockA.attributes,\n\t\t\t\t\t\t...updatedAttributes,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t...blocksWithTheSameType.slice( 1 ),\n\t\t\t]\n\t\t) );\n\t},\n\tSETUP_EDITOR( action, store ) {\n\t\tconst { post, edits } = action;\n\t\tconst state = store.getState();\n\n\t\t// In order to ensure maximum of a single parse during setup, edits are\n\t\t// included as part of editor setup action. Assume edited content as\n\t\t// canonical if provided, falling back to post.\n\t\tlet content;\n\t\tif ( has( edits, [ 'content' ] ) ) {\n\t\t\tcontent = edits.content;\n\t\t} else {\n\t\t\tcontent = post.content.raw;\n\t\t}\n\n\t\tlet blocks = parse( content );\n\n\t\t// Apply a template for new posts only, if exists.\n\t\tconst isNewPost = post.status === 'auto-draft';\n\t\tconst template = getTemplate( state );\n\t\tif ( isNewPost && template ) {\n\t\t\tblocks = synchronizeBlocksWithTemplate( blocks, template );\n\t\t}\n\n\t\tconst setupAction = setupEditorState( post, blocks );\n\n\t\treturn compact( [\n\t\t\tsetupAction,\n\n\t\t\t// TODO: This is temporary, necessary only so long as editor setup\n\t\t\t// is a separate action from block resetting.\n\t\t\t//\n\t\t\t// See: https://github.com/WordPress/gutenberg/pull/9403\n\t\t\tvalidateBlocksToTemplate( setupAction, store ),\n\t\t] );\n\t},\n\tRESET_BLOCKS: [\n\t\tvalidateBlocksToTemplate,\n\t],\n\tSYNCHRONIZE_TEMPLATE( action, { getState } ) {\n\t\tconst state = getState();\n\t\tconst blocks = getBlocks( state );\n\t\tconst template = getTemplate( state );\n\t\tconst updatedBlockList = synchronizeBlocksWithTemplate( blocks, template );\n\n\t\treturn resetBlocks( updatedBlockList );\n\t},\n\tFETCH_REUSABLE_BLOCKS: ( action, store ) => {\n\t\tfetchReusableBlocks( action, store );\n\t},\n\tSAVE_REUSABLE_BLOCK: ( action, store ) => {\n\t\tsaveReusableBlocks( action, store );\n\t},\n\tDELETE_REUSABLE_BLOCK: ( action, store ) => {\n\t\tdeleteReusableBlocks( action, store );\n\t},\n\tRECEIVE_REUSABLE_BLOCKS: receiveReusableBlocks,\n\tCONVERT_BLOCK_TO_STATIC: convertBlockToStatic,\n\tCONVERT_BLOCK_TO_REUSABLE: convertBlockToReusable,\n\tREMOVE_BLOCKS: [\n\t\tselectPreviousBlock,\n\t\tensureDefaultBlock,\n\t],\n\tREPLACE_BLOCKS: [\n\t\tensureDefaultBlock,\n\t],\n\tMULTI_SELECT: ( action, { getState } ) => {\n\t\tconst blockCount = getSelectedBlockCount( getState() );\n\n\t\tspeak( sprintf( __( '%s blocks selected.' ), blockCount ), 'assertive' );\n\t},\n};\n"]}