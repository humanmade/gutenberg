{"version":3,"sources":["/home/circleci/project/packages/editor/src/store/selectors.js"],"names":["castArray","flatMap","find","first","get","has","includes","isArray","isBoolean","last","map","orderBy","reduce","size","some","createSelector","serialize","getBlockType","getBlockTypes","hasBlockSupport","hasChildBlocksWithInserterSupport","getFreeformContentHandlerName","isUnmodifiedDefaultBlock","isInTheFuture","getDate","removep","select","deprecated","PREFERENCES_DEFAULTS","POST_UPDATE_TRANSACTION_ID","PERMALINK_POSTNAME_REGEX","INSERTER_UTILITY_HIGH","INSERTER_UTILITY_MEDIUM","INSERTER_UTILITY_LOW","INSERTER_UTILITY_NONE","MILLISECONDS_PER_HOUR","MILLISECONDS_PER_DAY","MILLISECONDS_PER_WEEK","ONE_MINUTE_IN_MS","EMPTY_ARRAY","hasEditorUndo","state","editor","past","length","hasEditorRedo","future","isEditedPostNew","getCurrentPost","status","hasChangedContent","present","blocks","isDirty","edits","isEditedPostDirty","Object","keys","inSomeHistory","isCleanNewPost","currentPost","getCurrentPostType","type","getCurrentPostId","id","getCurrentPostRevisionsCount","getCurrentPostLastRevisionId","getPostEdits","initialEdits","getReferenceByDistinctEdits","getCurrentPostAttribute","attributeName","post","hasOwnProperty","getEditedPostAttribute","getEditedPostContent","getAutosaveAttribute","hasAutosave","autosave","getAutosave","getEditedPostVisibility","password","isCurrentPostPending","isCurrentPostPublished","indexOf","Date","Number","date","isCurrentPostScheduled","isEditedPostPublishable","isEditedPostSaveable","isSavingPost","isEditedPostEmpty","getBlocksForSerialization","name","isEditedPostAutosaveable","field","isEditedPostBeingScheduled","checkedDate","isEditedPostDateFloating","modified","getBlockDependantsCacheBust","clientId","getBlockOrder","innerBlockClientId","getBlock","getBlockName","block","byClientId","attributes","result","value","key","source","getPostMeta","meta","innerBlocks","getBlocks","rootClientId","getClientIdsOfDescendants","clientIds","descendants","getClientIdsWithDescendants","topLevelIds","order","getGlobalBlockCount","blockName","count","getBlocksByClientId","getBlockCount","getBlockSelectionStart","blockSelection","start","getBlockSelectionEnd","end","getSelectedBlockCount","multiSelectedBlockCount","getMultiSelectedBlockClientIds","hasSelectedBlock","getSelectedBlockClientId","getSelectedBlock","getBlockRootClientId","getBlockHierarchyRootClientId","current","getAdjacentBlockClientId","startClientId","modifier","undefined","getFirstMultiSelectedBlockClientId","getLastMultiSelectedBlockClientId","orderSet","index","nextIndex","getPreviousBlockClientId","getNextBlockClientId","getSelectedBlocksInitialCaretPosition","initialPosition","blockOrder","startIndex","endIndex","slice","getMultiSelectedBlocks","multiSelectedBlockClientIds","isFirstMultiSelectedBlock","isBlockMultiSelected","isAncestorMultiSelected","ancestorClientId","isMultiSelected","getMultiSelectedBlocksStartClientId","getMultiSelectedBlocksEndClientId","getBlockIndex","isBlockSelected","hasSelectedInnerBlock","deep","innerClientId","isBlockWithinSelection","hasMultiSelection","isMultiSelecting","isSelectionEnabled","isEnabled","getBlockMode","blocksMode","isTyping","isCaretWithinFormattedText","getBlockInsertionPoint","insertionPoint","isBlockInsertionPointVisible","isValidTemplate","template","isValid","getTemplate","settings","getTemplateLock","templateLock","blockListSettings","getBlockListSettings","saving","requesting","didPostSaveRequestSucceed","successful","didPostSaveRequestFail","error","isAutosavingPost","isAutosave","getSuggestedPostFormat","isSingleUnmodifiedDefaultBlock","content","isSingleFreeformBlock","canInsertBlockType","checkAllowList","list","item","defaultResult","blockType","getEditorSettings","allowedBlockTypes","isBlockAllowedInEditor","isLocked","parentBlockListSettings","parentAllowedBlocks","hasParentAllowedBlock","blockAllowedParentBlocks","parent","parentName","hasBlockAllowedParent","getInsertUsage","preferences","insertUsage","getInserterItems","calculateUtility","category","isContextual","calculateFrecency","time","duration","now","shouldIncludeBlockType","buildBlockTypeInserterItem","isDisabled","initialAttributes","title","icon","keywords","utility","frecency","shouldIncludeReusableBlock","reusableBlock","referencedBlock","referencedBlockType","buildReusableBlockInserterItem","ref","blockTypeInserterItems","filter","reusableBlockInserterItems","__experimentalGetReusableBlocks","reusableBlocks","data","__experimentalGetReusableBlock","isTemporary","isNaN","parseInt","__experimentalIsSavingReusableBlock","isSaving","__experimentalIsFetchingReusableBlock","isFetching","getStateBeforeOptimisticTransaction","transactionId","transaction","optimist","entry","beforeState","action","isPublishingPost","stateBeforeRequest","isPermalinkEditable","permalinkTemplate","test","getPermalink","getPermalinkParts","prefix","postName","suffix","split","predicate","getTokenSettings","tokens","isPostLocked","postLock","isPostSavingLocked","postSavingLock","isPostLockTakeover","isTakeover","getPostLockUser","user","getActivePostLock","activePostLock","canUserUseUnfilteredHTML","isPublishSidebarEnabled","getNotices","alternative","plugin","version","getReusableBlock","isSavingReusableBlock","hint","isFetchingReusableBlock","getReusableBlocks"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport {\n\tcastArray,\n\tflatMap,\n\tfind,\n\tfirst,\n\tget,\n\thas,\n\tincludes,\n\tisArray,\n\tisBoolean,\n\tlast,\n\tmap,\n\torderBy,\n\treduce,\n\tsize,\n\tsome,\n} from 'lodash';\nimport createSelector from 'rememo';\n\n/**\n * WordPress dependencies\n */\nimport {\n\tserialize,\n\tgetBlockType,\n\tgetBlockTypes,\n\thasBlockSupport,\n\thasChildBlocksWithInserterSupport,\n\tgetFreeformContentHandlerName,\n\tisUnmodifiedDefaultBlock,\n} from '@wordpress/blocks';\nimport { isInTheFuture, getDate } from '@wordpress/date';\nimport { removep } from '@wordpress/autop';\nimport { select } from '@wordpress/data';\nimport deprecated from '@wordpress/deprecated';\n\n/**\n * Dependencies\n */\nimport { PREFERENCES_DEFAULTS } from './defaults';\n\n/***\n * Module constants\n */\nexport const POST_UPDATE_TRANSACTION_ID = 'post-update';\nconst PERMALINK_POSTNAME_REGEX = /%(?:postname|pagename)%/;\nexport const INSERTER_UTILITY_HIGH = 3;\nexport const INSERTER_UTILITY_MEDIUM = 2;\nexport const INSERTER_UTILITY_LOW = 1;\nexport const INSERTER_UTILITY_NONE = 0;\nconst MILLISECONDS_PER_HOUR = 3600 * 1000;\nconst MILLISECONDS_PER_DAY = 24 * 3600 * 1000;\nconst MILLISECONDS_PER_WEEK = 7 * 24 * 3600 * 1000;\nconst ONE_MINUTE_IN_MS = 60 * 1000;\n\n/**\n * Shared reference to an empty array for cases where it is important to avoid\n * returning a new array reference on every invocation, as in a connected or\n * other pure component which performs `shouldComponentUpdate` check on props.\n * This should be used as a last resort, since the normalized data should be\n * maintained by the reducer result in state.\n *\n * @type {Array}\n */\nconst EMPTY_ARRAY = [];\n\n/**\n * Returns true if any past editor history snapshots exist, or false otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether undo history exists.\n */\nexport function hasEditorUndo( state ) {\n\treturn state.editor.past.length > 0;\n}\n\n/**\n * Returns true if any future editor history snapshots exist, or false\n * otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether redo history exists.\n */\nexport function hasEditorRedo( state ) {\n\treturn state.editor.future.length > 0;\n}\n\n/**\n * Returns true if the currently edited post is yet to be saved, or false if\n * the post has been saved.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post is new.\n */\nexport function isEditedPostNew( state ) {\n\treturn getCurrentPost( state ).status === 'auto-draft';\n}\n\n/**\n * Returns true if content includes unsaved changes, or false otherwise.\n *\n * @param {Object} state Editor state.\n *\n * @return {boolean} Whether content includes unsaved changes.\n */\nexport function hasChangedContent( state ) {\n\treturn (\n\t\tstate.editor.present.blocks.isDirty ||\n\n\t\t// `edits` is intended to contain only values which are different from\n\t\t// the saved post, so the mere presence of a property is an indicator\n\t\t// that the value is different than what is known to be saved. While\n\t\t// content in Visual mode is represented by the blocks state, in Text\n\t\t// mode it is tracked by `edits.content`.\n\t\t'content' in state.editor.present.edits\n\t);\n}\n\n/**\n * Returns true if there are unsaved values for the current edit session, or\n * false if the editing state matches the saved or new post.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether unsaved values exist.\n */\nexport function isEditedPostDirty( state ) {\n\tif ( hasChangedContent( state ) ) {\n\t\treturn true;\n\t}\n\n\t// Edits should contain only fields which differ from the saved post (reset\n\t// at initial load and save complete). Thus, a non-empty edits state can be\n\t// inferred to contain unsaved values.\n\tif ( Object.keys( state.editor.present.edits ).length > 0 ) {\n\t\treturn true;\n\t}\n\n\t// Edits and change detectiona are reset at the start of a save, but a post\n\t// is still considered dirty until the point at which the save completes.\n\t// Because the save is performed optimistically, the prior states are held\n\t// until committed. These can be referenced to determine whether there's a\n\t// chance that state may be reverted into one considered dirty.\n\treturn inSomeHistory( state, isEditedPostDirty );\n}\n\n/**\n * Returns true if there are no unsaved values for the current edit session and\n * if the currently edited post is new (has never been saved before).\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether new post and unsaved values exist.\n */\nexport function isCleanNewPost( state ) {\n\treturn ! isEditedPostDirty( state ) && isEditedPostNew( state );\n}\n\n/**\n * Returns the post currently being edited in its last known saved state, not\n * including unsaved edits. Returns an object containing relevant default post\n * values if the post has not yet been saved.\n *\n * @param {Object} state Global application state.\n *\n * @return {Object} Post object.\n */\nexport function getCurrentPost( state ) {\n\treturn state.currentPost;\n}\n\n/**\n * Returns the post type of the post currently being edited.\n *\n * @param {Object} state Global application state.\n *\n * @return {string} Post type.\n */\nexport function getCurrentPostType( state ) {\n\treturn state.currentPost.type;\n}\n\n/**\n * Returns the ID of the post currently being edited, or null if the post has\n * not yet been saved.\n *\n * @param {Object} state Global application state.\n *\n * @return {?number} ID of current post.\n */\nexport function getCurrentPostId( state ) {\n\treturn getCurrentPost( state ).id || null;\n}\n\n/**\n * Returns the number of revisions of the post currently being edited.\n *\n * @param {Object} state Global application state.\n *\n * @return {number} Number of revisions.\n */\nexport function getCurrentPostRevisionsCount( state ) {\n\treturn get( getCurrentPost( state ), [ '_links', 'version-history', 0, 'count' ], 0 );\n}\n\n/**\n * Returns the last revision ID of the post currently being edited,\n * or null if the post has no revisions.\n *\n * @param {Object} state Global application state.\n *\n * @return {?number} ID of the last revision.\n */\nexport function getCurrentPostLastRevisionId( state ) {\n\treturn get( getCurrentPost( state ), [ '_links', 'predecessor-version', 0, 'id' ], null );\n}\n\n/**\n * Returns any post values which have been changed in the editor but not yet\n * been saved.\n *\n * @param {Object} state Global application state.\n *\n * @return {Object} Object of key value pairs comprising unsaved edits.\n */\nexport const getPostEdits = createSelector(\n\t( state ) => {\n\t\treturn {\n\t\t\t...state.initialEdits,\n\t\t\t...state.editor.present.edits,\n\t\t};\n\t},\n\t( state ) => [\n\t\tstate.editor.present.edits,\n\t\tstate.initialEdits,\n\t]\n);\n\n/**\n * Returns a new reference when edited values have changed. This is useful in\n * inferring where an edit has been made between states by comparison of the\n * return values using strict equality.\n *\n * @example\n *\n * ```\n * const hasEditOccurred = (\n *    getReferenceByDistinctEdits( beforeState ) !==\n *    getReferenceByDistinctEdits( afterState )\n * );\n * ```\n *\n * @param {Object} state Editor state.\n *\n * @return {*} A value whose reference will change only when an edit occurs.\n */\nexport const getReferenceByDistinctEdits = createSelector(\n\t() => [],\n\t( state ) => [ state.editor ],\n);\n\n/**\n * Returns an attribute value of the saved post.\n *\n * @param {Object} state         Global application state.\n * @param {string} attributeName Post attribute name.\n *\n * @return {*} Post attribute value.\n */\nexport function getCurrentPostAttribute( state, attributeName ) {\n\tconst post = getCurrentPost( state );\n\tif ( post.hasOwnProperty( attributeName ) ) {\n\t\treturn post[ attributeName ];\n\t}\n}\n\n/**\n * Returns a single attribute of the post being edited, preferring the unsaved\n * edit if one exists, but falling back to the attribute for the last known\n * saved state of the post.\n *\n * @param {Object} state         Global application state.\n * @param {string} attributeName Post attribute name.\n *\n * @return {*} Post attribute value.\n */\nexport function getEditedPostAttribute( state, attributeName ) {\n\tconst edits = getPostEdits( state );\n\n\t// Special cases\n\tswitch ( attributeName ) {\n\t\tcase 'content':\n\t\t\treturn getEditedPostContent( state );\n\t}\n\n\tif ( ! edits.hasOwnProperty( attributeName ) ) {\n\t\treturn getCurrentPostAttribute( state, attributeName );\n\t}\n\n\treturn edits[ attributeName ];\n}\n\n/**\n * Returns an attribute value of the current autosave revision for a post, or\n * null if there is no autosave for the post.\n *\n * @param {Object} state         Global application state.\n * @param {string} attributeName Autosave attribute name.\n *\n * @return {*} Autosave attribute value.\n */\nexport function getAutosaveAttribute( state, attributeName ) {\n\tif ( ! hasAutosave( state ) ) {\n\t\treturn null;\n\t}\n\n\tconst autosave = getAutosave( state );\n\tif ( autosave.hasOwnProperty( attributeName ) ) {\n\t\treturn autosave[ attributeName ];\n\t}\n}\n\n/**\n * Returns the current visibility of the post being edited, preferring the\n * unsaved value if different than the saved post. The return value is one of\n * \"private\", \"password\", or \"public\".\n *\n * @param {Object} state Global application state.\n *\n * @return {string} Post visibility.\n */\nexport function getEditedPostVisibility( state ) {\n\tconst status = getEditedPostAttribute( state, 'status' );\n\tconst password = getEditedPostAttribute( state, 'password' );\n\n\tif ( status === 'private' ) {\n\t\treturn 'private';\n\t} else if ( password ) {\n\t\treturn 'password';\n\t}\n\treturn 'public';\n}\n\n/**\n * Returns true if post is pending review.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether current post is pending review.\n */\nexport function isCurrentPostPending( state ) {\n\treturn getCurrentPost( state ).status === 'pending';\n}\n\n/**\n * Return true if the current post has already been published.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post has been published.\n */\nexport function isCurrentPostPublished( state ) {\n\tconst post = getCurrentPost( state );\n\n\treturn [ 'publish', 'private' ].indexOf( post.status ) !== -1 ||\n\t\t( post.status === 'future' && ! isInTheFuture( new Date( Number( getDate( post.date ) ) - ONE_MINUTE_IN_MS ) ) );\n}\n\n/**\n * Returns true if post is already scheduled.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether current post is scheduled to be posted.\n */\nexport function isCurrentPostScheduled( state ) {\n\treturn getCurrentPost( state ).status === 'future' && ! isCurrentPostPublished( state );\n}\n\n/**\n * Return true if the post being edited can be published.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post can been published.\n */\nexport function isEditedPostPublishable( state ) {\n\tconst post = getCurrentPost( state );\n\n\t// TODO: Post being publishable should be superset of condition of post\n\t// being saveable. Currently this restriction is imposed at UI.\n\t//\n\t//  See: <PostPublishButton /> (`isButtonEnabled` assigned by `isSaveable`)\n\n\treturn isEditedPostDirty( state ) || [ 'publish', 'private', 'future' ].indexOf( post.status ) === -1;\n}\n\n/**\n * Returns true if the post can be saved, or false otherwise. A post must\n * contain a title, an excerpt, or non-empty content to be valid for save.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post can be saved.\n */\nexport function isEditedPostSaveable( state ) {\n\tif ( isSavingPost( state ) ) {\n\t\treturn false;\n\t}\n\n\t// TODO: Post should not be saveable if not dirty. Cannot be added here at\n\t// this time since posts where meta boxes are present can be saved even if\n\t// the post is not dirty. Currently this restriction is imposed at UI, but\n\t// should be moved here.\n\t//\n\t//  See: `isEditedPostPublishable` (includes `isEditedPostDirty` condition)\n\t//  See: <PostSavedState /> (`forceIsDirty` prop)\n\t//  See: <PostPublishButton /> (`forceIsDirty` prop)\n\t//  See: https://github.com/WordPress/gutenberg/pull/4184\n\n\treturn (\n\t\t!! getEditedPostAttribute( state, 'title' ) ||\n\t\t!! getEditedPostAttribute( state, 'excerpt' ) ||\n\t\t! isEditedPostEmpty( state )\n\t);\n}\n\n/**\n * Returns true if the edited post has content. A post has content if it has at\n * least one saveable block or otherwise has a non-empty content property\n * assigned.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether post has content.\n */\nexport function isEditedPostEmpty( state ) {\n\tconst blocks = getBlocksForSerialization( state );\n\n\t// While the condition of truthy content string is sufficient to determine\n\t// emptiness, testing saveable blocks length is a trivial operation. Since\n\t// this function can be called frequently, optimize for the fast case as a\n\t// condition of the mere existence of blocks. Note that the value of edited\n\t// content is used in place of blocks, thus allowed to fall through.\n\tif ( blocks.length && ! ( 'content' in getPostEdits( state ) ) ) {\n\t\t// Pierce the abstraction of the serializer in knowing that blocks are\n\t\t// joined with with newlines such that even if every individual block\n\t\t// produces an empty save result, the serialized content is non-empty.\n\t\tif ( blocks.length > 1 ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Freeform and unregistered blocks omit comment delimiters in their\n\t\t// output. The freeform block specifically may produce an empty string\n\t\t// to save. In the case of a single freeform block, fall through to the\n\t\t// full serialize. Otherwise, the single block is assumed non-empty by\n\t\t// virtue of its comment delimiters.\n\t\tif ( blocks[ 0 ].name !== getFreeformContentHandlerName() ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn ! getEditedPostContent( state );\n}\n\n/**\n * Returns true if the post can be autosaved, or false otherwise.\n *\n * @param  {Object}  state Global application state.\n *\n * @return {boolean} Whether the post can be autosaved.\n */\nexport function isEditedPostAutosaveable( state ) {\n\t// A post must contain a title, an excerpt, or non-empty content to be valid for autosaving.\n\tif ( ! isEditedPostSaveable( state ) ) {\n\t\treturn false;\n\t}\n\n\t// If we don't already have an autosave, the post is autosaveable.\n\tif ( ! hasAutosave( state ) ) {\n\t\treturn true;\n\t}\n\n\t// To avoid an expensive content serialization, use the content dirtiness\n\t// flag in place of content field comparison against the known autosave.\n\t// This is not strictly accurate, and relies on a tolerance toward autosave\n\t// request failures for unnecessary saves.\n\tif ( hasChangedContent( state ) ) {\n\t\treturn true;\n\t}\n\n\t// If the title, excerpt or content has changed, the post is autosaveable.\n\tconst autosave = getAutosave( state );\n\treturn [ 'title', 'excerpt' ].some( ( field ) => (\n\t\tautosave[ field ] !== getEditedPostAttribute( state, field )\n\t) );\n}\n\n/**\n * Returns the current autosave, or null if one is not set (i.e. if the post\n * has yet to be autosaved, or has been saved or published since the last\n * autosave).\n *\n * @param {Object} state Editor state.\n *\n * @return {?Object} Current autosave, if exists.\n */\nexport function getAutosave( state ) {\n\treturn state.autosave;\n}\n\n/**\n * Returns the true if there is an existing autosave, otherwise false.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether there is an existing autosave.\n */\nexport function hasAutosave( state ) {\n\treturn !! getAutosave( state );\n}\n\n/**\n * Return true if the post being edited is being scheduled. Preferring the\n * unsaved status values.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post has been published.\n */\nexport function isEditedPostBeingScheduled( state ) {\n\tconst date = getEditedPostAttribute( state, 'date' );\n\t// Offset the date by one minute (network latency)\n\tconst checkedDate = new Date( Number( getDate( date ) ) - ONE_MINUTE_IN_MS );\n\n\treturn isInTheFuture( checkedDate );\n}\n\n/**\n * Returns whether the current post should be considered to have a \"floating\"\n * date (i.e. that it would publish \"Immediately\" rather than at a set time).\n *\n * Unlike in the PHP backend, the REST API returns a full date string for posts\n * where the 0000-00-00T00:00:00 placeholder is present in the database. To\n * infer that a post is set to publish \"Immediately\" we check whether the date\n * and modified date are the same.\n *\n * @param  {Object}  state Editor state.\n *\n * @return {boolean} Whether the edited post has a floating date value.\n */\nexport function isEditedPostDateFloating( state ) {\n\tconst date = getEditedPostAttribute( state, 'date' );\n\tconst modified = getEditedPostAttribute( state, 'modified' );\n\tconst status = getEditedPostAttribute( state, 'status' );\n\tif ( status === 'draft' || status === 'auto-draft' ) {\n\t\treturn date === modified;\n\t}\n\treturn false;\n}\n\n/**\n * Returns a new reference when the inner blocks of a given block client ID\n * change. This is used exclusively as a memoized selector dependant, relying\n * on this selector's shared return value and recursively those of its inner\n * blocks defined as dependencies. This abuses mechanics of the selector\n * memoization to return from the original selector function only when\n * dependants change.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {*} A value whose reference will change only when inner blocks of\n *             the given block client ID change.\n */\nexport const getBlockDependantsCacheBust = createSelector(\n\t() => [],\n\t( state, clientId ) => map(\n\t\tgetBlockOrder( state, clientId ),\n\t\t( innerBlockClientId ) => getBlock( state, innerBlockClientId ),\n\t),\n);\n\n/**\n * Returns a block's name given its client ID, or null if no block exists with\n * the client ID.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {string} Block name.\n */\nexport function getBlockName( state, clientId ) {\n\tconst block = state.editor.present.blocks.byClientId[ clientId ];\n\treturn block ? block.name : null;\n}\n\n/**\n * Returns a block given its client ID. This is a parsed copy of the block,\n * containing its `blockName`, `clientId`, and current `attributes` state. This\n * is not the block's registration settings, which must be retrieved from the\n * blocks module registration store.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {Object} Parsed block object.\n */\nexport const getBlock = createSelector(\n\t( state, clientId ) => {\n\t\tconst block = state.editor.present.blocks.byClientId[ clientId ];\n\t\tif ( ! block ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet { attributes } = block;\n\n\t\t// Inject custom source attribute values.\n\t\t//\n\t\t// TODO: Create generic external sourcing pattern, not explicitly\n\t\t// targeting meta attributes.\n\t\tconst type = getBlockType( block.name );\n\t\tif ( type ) {\n\t\t\tattributes = reduce( type.attributes, ( result, value, key ) => {\n\t\t\t\tif ( value.source === 'meta' ) {\n\t\t\t\t\tif ( result === attributes ) {\n\t\t\t\t\t\tresult = { ...result };\n\t\t\t\t\t}\n\n\t\t\t\t\tresult[ key ] = getPostMeta( state, value.meta );\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}, attributes );\n\t\t}\n\n\t\treturn {\n\t\t\t...block,\n\t\t\tattributes,\n\t\t\tinnerBlocks: getBlocks( state, clientId ),\n\t\t};\n\t},\n\t( state, clientId ) => [\n\t\tstate.editor.present.blocks.byClientId[ clientId ],\n\t\tgetBlockDependantsCacheBust( state, clientId ),\n\t\tstate.editor.present.edits.meta,\n\t\tstate.initialEdits.meta,\n\t\tstate.currentPost.meta,\n\t]\n);\n\nfunction getPostMeta( state, key ) {\n\treturn has( state, [ 'editor', 'present', 'edits', 'meta', key ] ) ?\n\t\tget( state, [ 'editor', 'present', 'edits', 'meta', key ] ) :\n\t\tget( state, [ 'currentPost', 'meta', key ] );\n}\n\n/**\n * Returns all block objects for the current post being edited as an array in\n * the order they appear in the post.\n *\n * Note: It's important to memoize this selector to avoid return a new instance\n * on each call\n *\n * @param {Object}  state        Editor state.\n * @param {?String} rootClientId Optional root client ID of block list.\n *\n * @return {Object[]} Post blocks.\n */\nexport const getBlocks = createSelector(\n\t( state, rootClientId ) => {\n\t\treturn map(\n\t\t\tgetBlockOrder( state, rootClientId ),\n\t\t\t( clientId ) => getBlock( state, clientId )\n\t\t);\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks,\n\t]\n);\n\n/**\n * Returns an array containing the clientIds of all descendants\n * of the blocks given.\n *\n * @param {Object} state Global application state.\n * @param {Array} clientIds Array of blocks to inspect.\n *\n * @return {Array} ids of descendants.\n */\nexport const getClientIdsOfDescendants = ( state, clientIds ) => flatMap( clientIds, ( clientId ) => {\n\tconst descendants = getBlockOrder( state, clientId );\n\treturn [ ...descendants, ...getClientIdsOfDescendants( state, descendants ) ];\n} );\n\n/**\n * Returns an array containing the clientIds of the top-level blocks\n * and their descendants of any depth (for nested blocks).\n *\n * @param {Object} state Global application state.\n *\n * @return {Array} ids of top-level and descendant blocks.\n */\nexport const getClientIdsWithDescendants = createSelector(\n\t( state ) => {\n\t\tconst topLevelIds = getBlockOrder( state );\n\t\treturn [ ...topLevelIds, ...getClientIdsOfDescendants( state, topLevelIds ) ];\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks.order,\n\t]\n);\n\n/**\n * Returns the total number of blocks, or the total number of blocks with a specific name in a post.\n * The number returned includes nested blocks.\n *\n * @param {Object}  state     Global application state.\n * @param {?String} blockName Optional block name, if specified only blocks of that type will be counted.\n *\n * @return {number} Number of blocks in the post, or number of blocks with name equal to blockName.\n */\nexport const getGlobalBlockCount = createSelector(\n\t( state, blockName ) => {\n\t\tif ( ! blockName ) {\n\t\t\treturn size( state.editor.present.blocks.byClientId );\n\t\t}\n\t\treturn reduce(\n\t\t\tstate.editor.present.blocks.byClientId,\n\t\t\t( count, block ) => block.name === blockName ? count + 1 : count,\n\t\t\t0\n\t\t);\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks.byClientId,\n\t]\n);\n\n/**\n * Given an array of block client IDs, returns the corresponding array of block\n * objects.\n *\n * @param {Object}   state     Editor state.\n * @param {string[]} clientIds Client IDs for which blocks are to be returned.\n *\n * @return {WPBlock[]} Block objects.\n */\nexport const getBlocksByClientId = createSelector(\n\t( state, clientIds ) => map(\n\t\tcastArray( clientIds ),\n\t\t( clientId ) => getBlock( state, clientId )\n\t),\n\t( state ) => [\n\t\tstate.editor.present.edits.meta,\n\t\tstate.initialEdits.meta,\n\t\tstate.currentPost.meta,\n\t\tstate.editor.present.blocks,\n\t]\n);\n\n/**\n * Returns the number of blocks currently present in the post.\n *\n * @param {Object}  state        Editor state.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {number} Number of blocks in the post.\n */\nexport function getBlockCount( state, rootClientId ) {\n\treturn getBlockOrder( state, rootClientId ).length;\n}\n\n/**\n * Returns the current block selection start. This value may be null, and it\n * may represent either a singular block selection or multi-selection start.\n * A selection is singular if its start and end match.\n *\n * @param {Object} state Global application state.\n *\n * @return {?string} Client ID of block selection start.\n */\nexport function getBlockSelectionStart( state ) {\n\treturn state.blockSelection.start;\n}\n\n/**\n * Returns the current block selection end. This value may be null, and it\n * may represent either a singular block selection or multi-selection end.\n * A selection is singular if its start and end match.\n *\n * @param {Object} state Global application state.\n *\n * @return {?string} Client ID of block selection end.\n */\nexport function getBlockSelectionEnd( state ) {\n\treturn state.blockSelection.end;\n}\n\n/**\n * Returns the number of blocks currently selected in the post.\n *\n * @param {Object} state Global application state.\n *\n * @return {number} Number of blocks selected in the post.\n */\nexport function getSelectedBlockCount( state ) {\n\tconst multiSelectedBlockCount = getMultiSelectedBlockClientIds( state ).length;\n\n\tif ( multiSelectedBlockCount ) {\n\t\treturn multiSelectedBlockCount;\n\t}\n\n\treturn state.blockSelection.start ? 1 : 0;\n}\n\n/**\n * Returns true if there is a single selected block, or false otherwise.\n *\n * @param {Object} state Editor state.\n *\n * @return {boolean} Whether a single block is selected.\n */\nexport function hasSelectedBlock( state ) {\n\tconst { start, end } = state.blockSelection;\n\treturn !! start && start === end;\n}\n\n/**\n * Returns the currently selected block client ID, or null if there is no\n * selected block.\n *\n * @param {Object} state Editor state.\n *\n * @return {?string} Selected block client ID.\n */\nexport function getSelectedBlockClientId( state ) {\n\tconst { start, end } = state.blockSelection;\n\treturn start === end && start ? start : null;\n}\n\n/**\n * Returns the currently selected block, or null if there is no selected block.\n *\n * @param {Object} state Global application state.\n *\n * @return {?Object} Selected block.\n */\nexport function getSelectedBlock( state ) {\n\tconst clientId = getSelectedBlockClientId( state );\n\treturn clientId ? getBlock( state, clientId ) : null;\n}\n\n/**\n * Given a block client ID, returns the root block from which the block is\n * nested, an empty string for top-level blocks, or null if the block does not\n * exist.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block from which to find root client ID.\n *\n * @return {?string} Root client ID, if exists\n */\nexport const getBlockRootClientId = createSelector(\n\t( state, clientId ) => {\n\t\tconst { order } = state.editor.present.blocks;\n\n\t\tfor ( const rootClientId in order ) {\n\t\t\tif ( includes( order[ rootClientId ], clientId ) ) {\n\t\t\t\treturn rootClientId;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks.order,\n\t]\n);\n\n/**\n * Given a block client ID, returns the root of the hierarchy from which the block is nested, return the block itself for root level blocks.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block from which to find root client ID.\n *\n * @return {string} Root client ID\n */\nexport const getBlockHierarchyRootClientId = createSelector(\n\t( state, clientId ) => {\n\t\tlet rootClientId = clientId;\n\t\tlet current = clientId;\n\t\twhile ( rootClientId ) {\n\t\t\tcurrent = rootClientId;\n\t\t\trootClientId = getBlockRootClientId( state, current );\n\t\t}\n\n\t\treturn current;\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks.order,\n\t]\n);\n\n/**\n * Returns the client ID of the block adjacent one at the given reference\n * startClientId and modifier directionality. Defaults start startClientId to\n * the selected block, and direction as next block. Returns null if there is no\n * adjacent block.\n *\n * @param {Object}  state         Editor state.\n * @param {?string} startClientId Optional client ID of block from which to\n *                                search.\n * @param {?number} modifier      Directionality multiplier (1 next, -1\n *                                previous).\n *\n * @return {?string} Return the client ID of the block, or null if none exists.\n */\nexport function getAdjacentBlockClientId( state, startClientId, modifier = 1 ) {\n\t// Default to selected block.\n\tif ( startClientId === undefined ) {\n\t\tstartClientId = getSelectedBlockClientId( state );\n\t}\n\n\t// Try multi-selection starting at extent based on modifier.\n\tif ( startClientId === undefined ) {\n\t\tif ( modifier < 0 ) {\n\t\t\tstartClientId = getFirstMultiSelectedBlockClientId( state );\n\t\t} else {\n\t\t\tstartClientId = getLastMultiSelectedBlockClientId( state );\n\t\t}\n\t}\n\n\t// Validate working start client ID.\n\tif ( ! startClientId ) {\n\t\treturn null;\n\t}\n\n\t// Retrieve start block root client ID, being careful to allow the falsey\n\t// empty string top-level root by explicitly testing against null.\n\tconst rootClientId = getBlockRootClientId( state, startClientId );\n\tif ( rootClientId === null ) {\n\t\treturn null;\n\t}\n\n\tconst { order } = state.editor.present.blocks;\n\tconst orderSet = order[ rootClientId ];\n\tconst index = orderSet.indexOf( startClientId );\n\tconst nextIndex = ( index + ( 1 * modifier ) );\n\n\t// Block was first in set and we're attempting to get previous.\n\tif ( nextIndex < 0 ) {\n\t\treturn null;\n\t}\n\n\t// Block was last in set and we're attempting to get next.\n\tif ( nextIndex === orderSet.length ) {\n\t\treturn null;\n\t}\n\n\t// Assume incremented index is within the set.\n\treturn orderSet[ nextIndex ];\n}\n\n/**\n * Returns the previous block's client ID from the given reference start ID.\n * Defaults start to the selected block. Returns null if there is no previous\n * block.\n *\n * @param {Object}  state         Editor state.\n * @param {?string} startClientId Optional client ID of block from which to\n *                                search.\n *\n * @return {?string} Adjacent block's client ID, or null if none exists.\n */\nexport function getPreviousBlockClientId( state, startClientId ) {\n\treturn getAdjacentBlockClientId( state, startClientId, -1 );\n}\n\n/**\n * Returns the next block's client ID from the given reference start ID.\n * Defaults start to the selected block. Returns null if there is no next\n * block.\n *\n * @param {Object}  state         Editor state.\n * @param {?string} startClientId Optional client ID of block from which to\n *                                search.\n *\n * @return {?string} Adjacent block's client ID, or null if none exists.\n */\nexport function getNextBlockClientId( state, startClientId ) {\n\treturn getAdjacentBlockClientId( state, startClientId, 1 );\n}\n\n/**\n * Returns the initial caret position for the selected block.\n * This position is to used to position the caret properly when the selected block changes.\n *\n * @param {Object} state Global application state.\n *\n * @return {?Object} Selected block.\n */\nexport function getSelectedBlocksInitialCaretPosition( state ) {\n\tconst { start, end } = state.blockSelection;\n\tif ( start !== end || ! start ) {\n\t\treturn null;\n\t}\n\n\treturn state.blockSelection.initialPosition;\n}\n\n/**\n * Returns the current multi-selection set of block client IDs, or an empty\n * array if there is no multi-selection.\n *\n * @param {Object} state Editor state.\n *\n * @return {Array} Multi-selected block client IDs.\n */\nexport const getMultiSelectedBlockClientIds = createSelector(\n\t( state ) => {\n\t\tconst { start, end } = state.blockSelection;\n\t\tif ( start === end ) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Retrieve root client ID to aid in retrieving relevant nested block\n\t\t// order, being careful to allow the falsey empty string top-level root\n\t\t// by explicitly testing against null.\n\t\tconst rootClientId = getBlockRootClientId( state, start );\n\t\tif ( rootClientId === null ) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst blockOrder = getBlockOrder( state, rootClientId );\n\t\tconst startIndex = blockOrder.indexOf( start );\n\t\tconst endIndex = blockOrder.indexOf( end );\n\n\t\tif ( startIndex > endIndex ) {\n\t\t\treturn blockOrder.slice( endIndex, startIndex + 1 );\n\t\t}\n\n\t\treturn blockOrder.slice( startIndex, endIndex + 1 );\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks.order,\n\t\tstate.blockSelection.start,\n\t\tstate.blockSelection.end,\n\t],\n);\n\n/**\n * Returns the current multi-selection set of blocks, or an empty array if\n * there is no multi-selection.\n *\n * @param {Object} state Editor state.\n *\n * @return {Array} Multi-selected block objects.\n */\nexport const getMultiSelectedBlocks = createSelector(\n\t( state ) => {\n\t\tconst multiSelectedBlockClientIds = getMultiSelectedBlockClientIds( state );\n\t\tif ( ! multiSelectedBlockClientIds.length ) {\n\t\t\treturn EMPTY_ARRAY;\n\t\t}\n\n\t\treturn multiSelectedBlockClientIds.map( ( clientId ) => getBlock( state, clientId ) );\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks.order,\n\t\tstate.blockSelection.start,\n\t\tstate.blockSelection.end,\n\t\tstate.editor.present.blocks.byClientId,\n\t\tstate.editor.present.edits.meta,\n\t\tstate.initialEdits.meta,\n\t\tstate.currentPost.meta,\n\t]\n);\n\n/**\n * Returns the client ID of the first block in the multi-selection set, or null\n * if there is no multi-selection.\n *\n * @param {Object} state Editor state.\n *\n * @return {?string} First block client ID in the multi-selection set.\n */\nexport function getFirstMultiSelectedBlockClientId( state ) {\n\treturn first( getMultiSelectedBlockClientIds( state ) ) || null;\n}\n\n/**\n * Returns the client ID of the last block in the multi-selection set, or null\n * if there is no multi-selection.\n *\n * @param {Object} state Editor state.\n *\n * @return {?string} Last block client ID in the multi-selection set.\n */\nexport function getLastMultiSelectedBlockClientId( state ) {\n\treturn last( getMultiSelectedBlockClientIds( state ) ) || null;\n}\n\n/**\n * Returns true if a multi-selection exists, and the block corresponding to the\n * specified client ID is the first block of the multi-selection set, or false\n * otherwise.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {boolean} Whether block is first in multi-selection.\n */\nexport function isFirstMultiSelectedBlock( state, clientId ) {\n\treturn getFirstMultiSelectedBlockClientId( state ) === clientId;\n}\n\n/**\n * Returns true if the client ID occurs within the block multi-selection, or\n * false otherwise.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {boolean} Whether block is in multi-selection set.\n */\nexport function isBlockMultiSelected( state, clientId ) {\n\treturn getMultiSelectedBlockClientIds( state ).indexOf( clientId ) !== -1;\n}\n\n/**\n * Returns true if an ancestor of the block is multi-selected, or false\n * otherwise.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {boolean} Whether an ancestor of the block is in multi-selection\n *                   set.\n */\nexport const isAncestorMultiSelected = createSelector(\n\t( state, clientId ) => {\n\t\tlet ancestorClientId = clientId;\n\t\tlet isMultiSelected = false;\n\t\twhile ( ancestorClientId && ! isMultiSelected ) {\n\t\t\tancestorClientId = getBlockRootClientId( state, ancestorClientId );\n\t\t\tisMultiSelected = isBlockMultiSelected( state, ancestorClientId );\n\t\t}\n\t\treturn isMultiSelected;\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks.order,\n\t\tstate.blockSelection.start,\n\t\tstate.blockSelection.end,\n\t],\n);\n/**\n * Returns the client ID of the block which begins the multi-selection set, or\n * null if there is no multi-selection.\n *\n * This is not necessarily the first client ID in the selection.\n *\n * @see getFirstMultiSelectedBlockClientId\n *\n * @param {Object} state Editor state.\n *\n * @return {?string} Client ID of block beginning multi-selection.\n */\nexport function getMultiSelectedBlocksStartClientId( state ) {\n\tconst { start, end } = state.blockSelection;\n\tif ( start === end ) {\n\t\treturn null;\n\t}\n\treturn start || null;\n}\n\n/**\n * Returns the client ID of the block which ends the multi-selection set, or\n * null if there is no multi-selection.\n *\n * This is not necessarily the last client ID in the selection.\n *\n * @see getLastMultiSelectedBlockClientId\n *\n * @param {Object} state Editor state.\n *\n * @return {?string} Client ID of block ending multi-selection.\n */\nexport function getMultiSelectedBlocksEndClientId( state ) {\n\tconst { start, end } = state.blockSelection;\n\tif ( start === end ) {\n\t\treturn null;\n\t}\n\treturn end || null;\n}\n\n/**\n * Returns an array containing all block client IDs in the editor in the order\n * they appear. Optionally accepts a root client ID of the block list for which\n * the order should be returned, defaulting to the top-level block order.\n *\n * @param {Object}  state        Editor state.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {Array} Ordered client IDs of editor blocks.\n */\nexport function getBlockOrder( state, rootClientId ) {\n\treturn state.editor.present.blocks.order[ rootClientId || '' ] || EMPTY_ARRAY;\n}\n\n/**\n * Returns the index at which the block corresponding to the specified client\n * ID occurs within the block order, or `-1` if the block does not exist.\n *\n * @param {Object}  state        Editor state.\n * @param {string}  clientId     Block client ID.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {number} Index at which block exists in order.\n */\nexport function getBlockIndex( state, clientId, rootClientId ) {\n\treturn getBlockOrder( state, rootClientId ).indexOf( clientId );\n}\n\n/**\n * Returns true if the block corresponding to the specified client ID is\n * currently selected and no multi-selection exists, or false otherwise.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {boolean} Whether block is selected and multi-selection exists.\n */\nexport function isBlockSelected( state, clientId ) {\n\tconst { start, end } = state.blockSelection;\n\n\tif ( start !== end ) {\n\t\treturn false;\n\t}\n\n\treturn start === clientId;\n}\n\n/**\n * Returns true if one of the block's inner blocks is selected.\n *\n * @param {Object}  state    Editor state.\n * @param {string}  clientId Block client ID.\n * @param {boolean} deep     Perform a deep check.\n *\n * @return {boolean} Whether the block as an inner block selected\n */\nexport function hasSelectedInnerBlock( state, clientId, deep = false ) {\n\treturn some(\n\t\tgetBlockOrder( state, clientId ),\n\t\t( innerClientId ) => (\n\t\t\tisBlockSelected( state, innerClientId ) ||\n\t\t\tisBlockMultiSelected( state, innerClientId ) ||\n\t\t\t( deep && hasSelectedInnerBlock( state, innerClientId, deep ) )\n\t\t)\n\t);\n}\n\n/**\n * Returns true if the block corresponding to the specified client ID is\n * currently selected but isn't the last of the selected blocks. Here \"last\"\n * refers to the block sequence in the document, _not_ the sequence of\n * multi-selection, which is why `state.blockSelection.end` isn't used.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {boolean} Whether block is selected and not the last in the\n *                   selection.\n */\nexport function isBlockWithinSelection( state, clientId ) {\n\tif ( ! clientId ) {\n\t\treturn false;\n\t}\n\n\tconst clientIds = getMultiSelectedBlockClientIds( state );\n\tconst index = clientIds.indexOf( clientId );\n\treturn index > -1 && index < clientIds.length - 1;\n}\n\n/**\n * Returns true if a multi-selection has been made, or false otherwise.\n *\n * @param {Object} state Editor state.\n *\n * @return {boolean} Whether multi-selection has been made.\n */\nexport function hasMultiSelection( state ) {\n\tconst { start, end } = state.blockSelection;\n\treturn start !== end;\n}\n\n/**\n * Whether in the process of multi-selecting or not. This flag is only true\n * while the multi-selection is being selected (by mouse move), and is false\n * once the multi-selection has been settled.\n *\n * @see hasMultiSelection\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} True if multi-selecting, false if not.\n */\nexport function isMultiSelecting( state ) {\n\treturn state.blockSelection.isMultiSelecting;\n}\n\n/**\n * Selector that returns if multi-selection is enabled or not.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} True if it should be possible to multi-select blocks, false if multi-selection is disabled.\n */\nexport function isSelectionEnabled( state ) {\n\treturn state.blockSelection.isEnabled;\n}\n\n/**\n * Returns the block's editing mode, defaulting to \"visual\" if not explicitly\n * assigned.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {Object} Block editing mode.\n */\nexport function getBlockMode( state, clientId ) {\n\treturn state.blocksMode[ clientId ] || 'visual';\n}\n\n/**\n * Returns true if the user is typing, or false otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether user is typing.\n */\nexport function isTyping( state ) {\n\treturn state.isTyping;\n}\n\n/**\n * Returns true if the caret is within formatted text, or false otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the caret is within formatted text.\n */\nexport function isCaretWithinFormattedText( state ) {\n\treturn state.isCaretWithinFormattedText;\n}\n\n/**\n * Returns the insertion point, the index at which the new inserted block would\n * be placed. Defaults to the last index.\n *\n * @param {Object} state Editor state.\n *\n * @return {Object} Insertion point object with `rootClientId`, `index`.\n */\nexport function getBlockInsertionPoint( state ) {\n\tlet rootClientId, index;\n\n\tconst { insertionPoint, blockSelection } = state;\n\tif ( insertionPoint !== null ) {\n\t\treturn insertionPoint;\n\t}\n\n\tconst { end } = blockSelection;\n\tif ( end ) {\n\t\trootClientId = getBlockRootClientId( state, end ) || undefined;\n\t\tindex = getBlockIndex( state, end, rootClientId ) + 1;\n\t} else {\n\t\tindex = getBlockOrder( state ).length;\n\t}\n\n\treturn { rootClientId, index };\n}\n\n/**\n * Returns true if we should show the block insertion point.\n *\n * @param {Object} state Global application state.\n *\n * @return {?boolean} Whether the insertion point is visible or not.\n */\nexport function isBlockInsertionPointVisible( state ) {\n\treturn state.insertionPoint !== null;\n}\n\n/**\n * Returns whether the blocks matches the template or not.\n *\n * @param {boolean} state\n * @return {?boolean} Whether the template is valid or not.\n */\nexport function isValidTemplate( state ) {\n\treturn state.template.isValid;\n}\n\n/**\n * Returns the defined block template\n *\n * @param {boolean} state\n * @return {?Array}        Block Template\n */\nexport function getTemplate( state ) {\n\treturn state.settings.template;\n}\n\n/**\n * Returns the defined block template lock. Optionally accepts a root block\n * client ID as context, otherwise defaulting to the global context.\n *\n * @param {Object}  state        Editor state.\n * @param {?string} rootClientId Optional block root client ID.\n *\n * @return {?string} Block Template Lock\n */\nexport function getTemplateLock( state, rootClientId ) {\n\tif ( ! rootClientId ) {\n\t\treturn state.settings.templateLock;\n\t}\n\n\tconst blockListSettings = getBlockListSettings( state, rootClientId );\n\tif ( ! blockListSettings ) {\n\t\treturn null;\n\t}\n\n\treturn blockListSettings.templateLock;\n}\n\n/**\n * Returns true if the post is currently being saved, or false otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether post is being saved.\n */\nexport function isSavingPost( state ) {\n\treturn state.saving.requesting;\n}\n\n/**\n * Returns true if a previous post save was attempted successfully, or false\n * otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post was saved successfully.\n */\nexport function didPostSaveRequestSucceed( state ) {\n\treturn state.saving.successful;\n}\n\n/**\n * Returns true if a previous post save was attempted but failed, or false\n * otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post save failed.\n */\nexport function didPostSaveRequestFail( state ) {\n\treturn !! state.saving.error;\n}\n\n/**\n * Returns true if the post is autosaving, or false otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post is autosaving.\n */\nexport function isAutosavingPost( state ) {\n\treturn isSavingPost( state ) && state.saving.isAutosave;\n}\n\n/**\n * Returns a suggested post format for the current post, inferred only if there\n * is a single block within the post and it is of a type known to match a\n * default post format. Returns null if the format cannot be determined.\n *\n * @param {Object} state Global application state.\n *\n * @return {?string} Suggested post format.\n */\nexport function getSuggestedPostFormat( state ) {\n\tconst blocks = getBlockOrder( state );\n\n\tlet name;\n\t// If there is only one block in the content of the post grab its name\n\t// so we can derive a suitable post format from it.\n\tif ( blocks.length === 1 ) {\n\t\tname = getBlock( state, blocks[ 0 ] ).name;\n\t}\n\n\t// If there are two blocks in the content and the last one is a text blocks\n\t// grab the name of the first one to also suggest a post format from it.\n\tif ( blocks.length === 2 ) {\n\t\tif ( getBlock( state, blocks[ 1 ] ).name === 'core/paragraph' ) {\n\t\t\tname = getBlock( state, blocks[ 0 ] ).name;\n\t\t}\n\t}\n\n\t// We only convert to default post formats in core.\n\tswitch ( name ) {\n\t\tcase 'core/image':\n\t\t\treturn 'image';\n\t\tcase 'core/quote':\n\t\tcase 'core/pullquote':\n\t\t\treturn 'quote';\n\t\tcase 'core/gallery':\n\t\t\treturn 'gallery';\n\t\tcase 'core/video':\n\t\tcase 'core-embed/youtube':\n\t\tcase 'core-embed/vimeo':\n\t\t\treturn 'video';\n\t\tcase 'core/audio':\n\t\tcase 'core-embed/spotify':\n\t\tcase 'core-embed/soundcloud':\n\t\t\treturn 'audio';\n\t}\n\n\treturn null;\n}\n\n/**\n * Returns a set of blocks which are to be used in consideration of the post's\n * generated save content.\n *\n * @param {Object} state Editor state.\n *\n * @return {WPBlock[]} Filtered set of blocks for save.\n */\nexport function getBlocksForSerialization( state ) {\n\tconst blocks = getBlocks( state );\n\n\t// A single unmodified default block is assumed to be equivalent to an\n\t// empty post.\n\tconst isSingleUnmodifiedDefaultBlock = (\n\t\tblocks.length === 1 &&\n\t\tisUnmodifiedDefaultBlock( blocks[ 0 ] )\n\t);\n\n\tif ( isSingleUnmodifiedDefaultBlock ) {\n\t\treturn [];\n\t}\n\n\treturn blocks;\n}\n\n/**\n * Returns the content of the post being edited, preferring raw string edit\n * before falling back to serialization of block state.\n *\n * @param {Object} state Global application state.\n *\n * @return {string} Post content.\n */\nexport const getEditedPostContent = createSelector(\n\t( state ) => {\n\t\tconst edits = getPostEdits( state );\n\t\tif ( 'content' in edits ) {\n\t\t\treturn edits.content;\n\t\t}\n\n\t\tconst blocks = getBlocksForSerialization( state );\n\t\tconst content = serialize( blocks );\n\n\t\t// For compatibility purposes, treat a post consisting of a single\n\t\t// freeform block as legacy content and downgrade to a pre-block-editor\n\t\t// removep'd content format.\n\t\tconst isSingleFreeformBlock = (\n\t\t\tblocks.length === 1 &&\n\t\t\tblocks[ 0 ].name === getFreeformContentHandlerName()\n\t\t);\n\n\t\tif ( isSingleFreeformBlock ) {\n\t\t\treturn removep( content );\n\t\t}\n\n\t\treturn content;\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks,\n\t\tstate.editor.present.edits.content,\n\t\tstate.initialEdits.content,\n\t],\n);\n\n/**\n * Determines if the given block type is allowed to be inserted into the block list.\n *\n * @param {Object}  state        Editor state.\n * @param {string}  blockName    The name of the block type, e.g.' core/paragraph'.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {boolean} Whether the given block type is allowed to be inserted.\n */\nexport const canInsertBlockType = createSelector(\n\t( state, blockName, rootClientId = null ) => {\n\t\tconst checkAllowList = ( list, item, defaultResult = null ) => {\n\t\t\tif ( isBoolean( list ) ) {\n\t\t\t\treturn list;\n\t\t\t}\n\t\t\tif ( isArray( list ) ) {\n\t\t\t\treturn includes( list, item );\n\t\t\t}\n\t\t\treturn defaultResult;\n\t\t};\n\n\t\tconst blockType = getBlockType( blockName );\n\t\tif ( ! blockType ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { allowedBlockTypes } = getEditorSettings( state );\n\n\t\tconst isBlockAllowedInEditor = checkAllowList( allowedBlockTypes, blockName, true );\n\t\tif ( ! isBlockAllowedInEditor ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst isLocked = !! getTemplateLock( state, rootClientId );\n\t\tif ( isLocked ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst parentBlockListSettings = getBlockListSettings( state, rootClientId );\n\t\tconst parentAllowedBlocks = get( parentBlockListSettings, [ 'allowedBlocks' ] );\n\t\tconst hasParentAllowedBlock = checkAllowList( parentAllowedBlocks, blockName );\n\n\t\tconst blockAllowedParentBlocks = blockType.parent;\n\t\tconst parentName = getBlockName( state, rootClientId );\n\t\tconst hasBlockAllowedParent = checkAllowList( blockAllowedParentBlocks, parentName );\n\n\t\tif ( hasParentAllowedBlock !== null && hasBlockAllowedParent !== null ) {\n\t\t\treturn hasParentAllowedBlock || hasBlockAllowedParent;\n\t\t} else if ( hasParentAllowedBlock !== null ) {\n\t\t\treturn hasParentAllowedBlock;\n\t\t} else if ( hasBlockAllowedParent !== null ) {\n\t\t\treturn hasBlockAllowedParent;\n\t\t}\n\n\t\treturn true;\n\t},\n\t( state, blockName, rootClientId ) => [\n\t\tstate.blockListSettings[ rootClientId ],\n\t\tstate.editor.present.blocks.byClientId[ rootClientId ],\n\t\tstate.settings.allowedBlockTypes,\n\t\tstate.settings.templateLock,\n\t],\n);\n\n/**\n * Returns information about how recently and frequently a block has been inserted.\n *\n * @param {Object} state Global application state.\n * @param {string} id    A string which identifies the insert, e.g. 'core/block/12'\n *\n * @return {?{ time: number, count: number }} An object containing `time` which is when the last\n *                                            insert occured as a UNIX epoch, and `count` which is\n *                                            the number of inserts that have occurred.\n */\nfunction getInsertUsage( state, id ) {\n\treturn state.preferences.insertUsage[ id ] || null;\n}\n\n/**\n * Determines the items that appear in the inserter. Includes both static\n * items (e.g. a regular block type) and dynamic items (e.g. a reusable block).\n *\n * Each item object contains what's necessary to display a button in the\n * inserter and handle its selection.\n *\n * The 'utility' property indicates how useful we think an item will be to the\n * user. There are 4 levels of utility:\n *\n * 1. Blocks that are contextually useful (utility = 3)\n * 2. Blocks that have been previously inserted (utility = 2)\n * 3. Blocks that are in the common category (utility = 1)\n * 4. All other blocks (utility = 0)\n *\n * The 'frecency' property is a heuristic (https://en.wikipedia.org/wiki/Frecency)\n * that combines block usage frequenty and recency.\n *\n * Items are returned ordered descendingly by their 'utility' and 'frecency'.\n *\n * @param {Object}  state        Editor state.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {Editor.InserterItem[]} Items that appear in inserter.\n *\n * @typedef {Object} Editor.InserterItem\n * @property {string}   id                Unique identifier for the item.\n * @property {string}   name              The type of block to create.\n * @property {Object}   initialAttributes Attributes to pass to the newly created block.\n * @property {string}   title             Title of the item, as it appears in the inserter.\n * @property {string}   icon              Dashicon for the item, as it appears in the inserter.\n * @property {string}   category          Block category that the item is associated with.\n * @property {string[]} keywords          Keywords that can be searched to find this item.\n * @property {boolean}  isDisabled        Whether or not the user should be prevented from inserting\n *                                        this item.\n * @property {number}   utility           How useful we think this item is, between 0 and 3.\n * @property {number}   frecency          Hueristic that combines frequency and recency.\n */\nexport const getInserterItems = createSelector(\n\t( state, rootClientId = null ) => {\n\t\tconst calculateUtility = ( category, count, isContextual ) => {\n\t\t\tif ( isContextual ) {\n\t\t\t\treturn INSERTER_UTILITY_HIGH;\n\t\t\t} else if ( count > 0 ) {\n\t\t\t\treturn INSERTER_UTILITY_MEDIUM;\n\t\t\t} else if ( category === 'common' ) {\n\t\t\t\treturn INSERTER_UTILITY_LOW;\n\t\t\t}\n\t\t\treturn INSERTER_UTILITY_NONE;\n\t\t};\n\n\t\tconst calculateFrecency = ( time, count ) => {\n\t\t\tif ( ! time ) {\n\t\t\t\treturn count;\n\t\t\t}\n\n\t\t\t// The selector is cached, which means Date.now() is the last time that the\n\t\t\t// relevant state changed. This suits our needs.\n\t\t\tconst duration = Date.now() - time;\n\n\t\t\tswitch ( true ) {\n\t\t\t\tcase duration < MILLISECONDS_PER_HOUR:\n\t\t\t\t\treturn count * 4;\n\t\t\t\tcase duration < MILLISECONDS_PER_DAY:\n\t\t\t\t\treturn count * 2;\n\t\t\t\tcase duration < MILLISECONDS_PER_WEEK:\n\t\t\t\t\treturn count / 2;\n\t\t\t\tdefault:\n\t\t\t\t\treturn count / 4;\n\t\t\t}\n\t\t};\n\n\t\tconst shouldIncludeBlockType = ( blockType ) => {\n\t\t\tif ( ! hasBlockSupport( blockType, 'inserter', true ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn canInsertBlockType( state, blockType.name, rootClientId );\n\t\t};\n\n\t\tconst buildBlockTypeInserterItem = ( blockType ) => {\n\t\t\tconst id = blockType.name;\n\n\t\t\tlet isDisabled = false;\n\t\t\tif ( ! hasBlockSupport( blockType.name, 'multiple', true ) ) {\n\t\t\t\tisDisabled = some( getBlocksByClientId( state, getClientIdsWithDescendants( state ) ), { name: blockType.name } );\n\t\t\t}\n\n\t\t\tconst isContextual = isArray( blockType.parent );\n\t\t\tconst { time, count = 0 } = getInsertUsage( state, id ) || {};\n\n\t\t\treturn {\n\t\t\t\tid,\n\t\t\t\tname: blockType.name,\n\t\t\t\tinitialAttributes: {},\n\t\t\t\ttitle: blockType.title,\n\t\t\t\ticon: blockType.icon,\n\t\t\t\tcategory: blockType.category,\n\t\t\t\tkeywords: blockType.keywords,\n\t\t\t\tisDisabled,\n\t\t\t\tutility: calculateUtility( blockType.category, count, isContextual ),\n\t\t\t\tfrecency: calculateFrecency( time, count ),\n\t\t\t\thasChildBlocksWithInserterSupport: hasChildBlocksWithInserterSupport( blockType.name ),\n\t\t\t};\n\t\t};\n\n\t\tconst shouldIncludeReusableBlock = ( reusableBlock ) => {\n\t\t\tif ( ! canInsertBlockType( state, 'core/block', rootClientId ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst referencedBlock = getBlock( state, reusableBlock.clientId );\n\t\t\tif ( ! referencedBlock ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst referencedBlockType = getBlockType( referencedBlock.name );\n\t\t\tif ( ! referencedBlockType ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif ( ! canInsertBlockType( state, referencedBlockType.name, rootClientId ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t};\n\n\t\tconst buildReusableBlockInserterItem = ( reusableBlock ) => {\n\t\t\tconst id = `core/block/${ reusableBlock.id }`;\n\n\t\t\tconst referencedBlock = getBlock( state, reusableBlock.clientId );\n\t\t\tconst referencedBlockType = getBlockType( referencedBlock.name );\n\n\t\t\tconst { time, count = 0 } = getInsertUsage( state, id ) || {};\n\t\t\tconst utility = calculateUtility( 'reusable', count, false );\n\t\t\tconst frecency = calculateFrecency( time, count );\n\n\t\t\treturn {\n\t\t\t\tid,\n\t\t\t\tname: 'core/block',\n\t\t\t\tinitialAttributes: { ref: reusableBlock.id },\n\t\t\t\ttitle: reusableBlock.title,\n\t\t\t\ticon: referencedBlockType.icon,\n\t\t\t\tcategory: 'reusable',\n\t\t\t\tkeywords: [],\n\t\t\t\tisDisabled: false,\n\t\t\t\tutility,\n\t\t\t\tfrecency,\n\t\t\t};\n\t\t};\n\n\t\tconst blockTypeInserterItems = getBlockTypes()\n\t\t\t.filter( shouldIncludeBlockType )\n\t\t\t.map( buildBlockTypeInserterItem );\n\n\t\tconst reusableBlockInserterItems = __experimentalGetReusableBlocks( state )\n\t\t\t.filter( shouldIncludeReusableBlock )\n\t\t\t.map( buildReusableBlockInserterItem );\n\n\t\treturn orderBy(\n\t\t\t[ ...blockTypeInserterItems, ...reusableBlockInserterItems ],\n\t\t\t[ 'utility', 'frecency' ],\n\t\t\t[ 'desc', 'desc' ]\n\t\t);\n\t},\n\t( state, rootClientId ) => [\n\t\tstate.blockListSettings[ rootClientId ],\n\t\tstate.editor.present.blocks,\n\t\tstate.preferences.insertUsage,\n\t\tstate.settings.allowedBlockTypes,\n\t\tstate.settings.templateLock,\n\t\tstate.reusableBlocks.data,\n\t\tgetBlockTypes(),\n\t],\n);\n\n/**\n * Returns the reusable block with the given ID.\n *\n * @param {Object}        state Global application state.\n * @param {number|string} ref   The reusable block's ID.\n *\n * @return {Object} The reusable block, or null if none exists.\n */\nexport const __experimentalGetReusableBlock = createSelector(\n\t( state, ref ) => {\n\t\tconst block = state.reusableBlocks.data[ ref ];\n\t\tif ( ! block ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst isTemporary = isNaN( parseInt( ref ) );\n\n\t\treturn {\n\t\t\t...block,\n\t\t\tid: isTemporary ? ref : +ref,\n\t\t\tisTemporary,\n\t\t};\n\t},\n\t( state, ref ) => [\n\t\tstate.reusableBlocks.data[ ref ],\n\t],\n);\n\n/**\n * Returns whether or not the reusable block with the given ID is being saved.\n *\n * @param {Object} state Global application state.\n * @param {string} ref   The reusable block's ID.\n *\n * @return {boolean} Whether or not the reusable block is being saved.\n */\nexport function __experimentalIsSavingReusableBlock( state, ref ) {\n\treturn state.reusableBlocks.isSaving[ ref ] || false;\n}\n\n/**\n * Returns true if the reusable block with the given ID is being fetched, or\n * false otherwise.\n *\n * @param {Object} state Global application state.\n * @param {string} ref   The reusable block's ID.\n *\n * @return {boolean} Whether the reusable block is being fetched.\n */\nexport function __experimentalIsFetchingReusableBlock( state, ref ) {\n\treturn !! state.reusableBlocks.isFetching[ ref ];\n}\n\n/**\n * Returns an array of all reusable blocks.\n *\n * @param {Object} state Global application state.\n *\n * @return {Array} An array of all reusable blocks.\n */\nexport function __experimentalGetReusableBlocks( state ) {\n\treturn map(\n\t\tstate.reusableBlocks.data,\n\t\t( value, ref ) => __experimentalGetReusableBlock( state, ref )\n\t);\n}\n\n/**\n * Returns state object prior to a specified optimist transaction ID, or `null`\n * if the transaction corresponding to the given ID cannot be found.\n *\n * @param {Object} state         Current global application state.\n * @param {Object} transactionId Optimist transaction ID.\n *\n * @return {Object} Global application state prior to transaction.\n */\nexport function getStateBeforeOptimisticTransaction( state, transactionId ) {\n\tconst transaction = find( state.optimist, ( entry ) => (\n\t\tentry.beforeState &&\n\t\tget( entry.action, [ 'optimist', 'id' ] ) === transactionId\n\t) );\n\n\treturn transaction ? transaction.beforeState : null;\n}\n\n/**\n * Returns true if the post is being published, or false otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether post is being published.\n */\nexport function isPublishingPost( state ) {\n\tif ( ! isSavingPost( state ) ) {\n\t\treturn false;\n\t}\n\n\t// Saving is optimistic, so assume that current post would be marked as\n\t// published if publishing\n\tif ( ! isCurrentPostPublished( state ) ) {\n\t\treturn false;\n\t}\n\n\t// Use post update transaction ID to retrieve the state prior to the\n\t// optimistic transaction\n\tconst stateBeforeRequest = getStateBeforeOptimisticTransaction(\n\t\tstate,\n\t\tPOST_UPDATE_TRANSACTION_ID\n\t);\n\n\t// Consider as publishing when current post prior to request was not\n\t// considered published\n\treturn !! stateBeforeRequest && ! isCurrentPostPublished( stateBeforeRequest );\n}\n\n/**\n * Returns whether the permalink is editable or not.\n *\n * @param {Object} state Editor state.\n *\n * @return {boolean} Whether or not the permalink is editable.\n */\nexport function isPermalinkEditable( state ) {\n\tconst permalinkTemplate = getEditedPostAttribute( state, 'permalink_template' );\n\n\treturn PERMALINK_POSTNAME_REGEX.test( permalinkTemplate );\n}\n\n/**\n * Returns the permalink for the post.\n *\n * @param {Object} state Editor state.\n *\n * @return {string} The permalink.\n */\nexport function getPermalink( state ) {\n\tconst { prefix, postName, suffix } = getPermalinkParts( state );\n\n\tif ( isPermalinkEditable( state ) ) {\n\t\treturn prefix + postName + suffix;\n\t}\n\n\treturn prefix;\n}\n\n/**\n * Returns the permalink for a post, split into it's three parts: the prefix, the postName, and the suffix.\n *\n * @param {Object} state Editor state.\n *\n * @return {Object} The prefix, postName, and suffix for the permalink.\n */\nexport function getPermalinkParts( state ) {\n\tconst permalinkTemplate = getEditedPostAttribute( state, 'permalink_template' );\n\tconst postName = getEditedPostAttribute( state, 'slug' ) || getEditedPostAttribute( state, 'generated_slug' );\n\n\tconst [ prefix, suffix ] = permalinkTemplate.split( PERMALINK_POSTNAME_REGEX );\n\n\treturn {\n\t\tprefix,\n\t\tpostName,\n\t\tsuffix,\n\t};\n}\n\n/**\n * Returns true if an optimistic transaction is pending commit, for which the\n * before state satisfies the given predicate function.\n *\n * @param {Object}   state     Editor state.\n * @param {Function} predicate Function given state, returning true if match.\n *\n * @return {boolean} Whether predicate matches for some history.\n */\nexport function inSomeHistory( state, predicate ) {\n\tconst { optimist } = state;\n\n\t// In recursion, optimist state won't exist. Assume exhausted options.\n\tif ( ! optimist ) {\n\t\treturn false;\n\t}\n\n\treturn optimist.some( ( { beforeState } ) => (\n\t\tbeforeState && predicate( beforeState )\n\t) );\n}\n\n/**\n * Returns the Block List settings of a block, if any exist.\n *\n * @param {Object}  state    Editor state.\n * @param {?string} clientId Block client ID.\n *\n * @return {?Object} Block settings of the block if set.\n */\nexport function getBlockListSettings( state, clientId ) {\n\treturn state.blockListSettings[ clientId ];\n}\n\n/**\n * Returns the editor settings.\n *\n * @param {Object} state Editor state.\n *\n * @return {Object} The editor settings object.\n */\nexport function getEditorSettings( state ) {\n\treturn state.settings;\n}\n\n/**\n * Returns the token settings.\n *\n * @param {Object} state Editor state.\n * @param {?string} name Token name.\n *\n * @return {Object} Token settings object, or the named token settings object if set.\n */\nexport function getTokenSettings( state, name ) {\n\tif ( ! name ) {\n\t\treturn state.tokens;\n\t}\n\n\treturn state.tokens[ name ];\n}\n\n/**\n * Returns whether the post is locked.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Is locked.\n */\nexport function isPostLocked( state ) {\n\treturn state.postLock.isLocked;\n}\n\n/**\n * Returns whether post saving is locked.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Is locked.\n */\nexport function isPostSavingLocked( state ) {\n\treturn Object.keys( state.postSavingLock ).length > 0;\n}\n\n/**\n * Returns whether the edition of the post has been taken over.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Is post lock takeover.\n */\nexport function isPostLockTakeover( state ) {\n\treturn state.postLock.isTakeover;\n}\n\n/**\n * Returns details about the post lock user.\n *\n * @param {Object} state Global application state.\n *\n * @return {Object} A user object.\n */\nexport function getPostLockUser( state ) {\n\treturn state.postLock.user;\n}\n\n/**\n * Returns the active post lock.\n *\n * @param {Object} state Global application state.\n *\n * @return {Object} The lock object.\n */\nexport function getActivePostLock( state ) {\n\treturn state.postLock.activePostLock;\n}\n\n/**\n * Returns whether or not the user has the unfiltered_html capability.\n *\n * @param {Object} state Editor state.\n *\n * @return {boolean} Whether the user can or can't post unfiltered HTML.\n */\nexport function canUserUseUnfilteredHTML( state ) {\n\treturn has( getCurrentPost( state ), [ '_links', 'wp:action-unfiltered-html' ] );\n}\n\n/**\n * Returns whether the pre-publish panel should be shown\n * or skipped when the user clicks the \"publish\" button.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the pre-publish panel should be shown or not.\n */\nexport function isPublishSidebarEnabled( state ) {\n\tif ( state.preferences.hasOwnProperty( 'isPublishSidebarEnabled' ) ) {\n\t\treturn state.preferences.isPublishSidebarEnabled;\n\t}\n\treturn PREFERENCES_DEFAULTS.isPublishSidebarEnabled;\n}\n\n//\n// Deprecated\n//\n\nexport function getNotices() {\n\tdeprecated( 'getNotices selector (`core/editor` store)', {\n\t\talternative: 'getNotices selector (`core/notices` store)',\n\t\tplugin: 'Gutenberg',\n\t\tversion: '4.4.0',\n\t} );\n\n\treturn select( 'core/notices' ).getNotices();\n}\n\nexport function getReusableBlock( state, ref ) {\n\tdeprecated( \"wp.data.select( 'core/editor' ).getReusableBlock( ref )\", {\n\t\talternative: \"wp.data.select( 'core' ).getEntityRecord( 'postType', 'wp_block', ref )\",\n\t\tplugin: 'Gutenberg',\n\t\tversion: '4.4.0',\n\t} );\n\n\treturn __experimentalGetReusableBlock( state, ref );\n}\n\nexport function isSavingReusableBlock( state, ref ) {\n\tdeprecated( 'isSavingReusableBlock selector (`core/editor` store)', {\n\t\talternative: '__experimentalIsSavingReusableBlock selector (`core/edtior` store)',\n\t\tplugin: 'Gutenberg',\n\t\tversion: '4.4.0',\n\t\thint: 'Using experimental APIs is strongly discouraged as they are subject to removal without notice.',\n\t} );\n\n\treturn __experimentalIsSavingReusableBlock( state, ref );\n}\n\nexport function isFetchingReusableBlock( state, ref ) {\n\tdeprecated( \"wp.data.select( 'core/editor' ).isFetchingReusableBlock( ref )\", {\n\t\talternative: \"wp.data.select( 'core' ).isResolving( 'getEntityRecord', 'wp_block', ref )\",\n\t\tplugin: 'Gutenberg',\n\t\tversion: '4.4.0',\n\t} );\n\n\treturn __experimentalIsFetchingReusableBlock( state, ref );\n}\n\nexport function getReusableBlocks( state ) {\n\tdeprecated( \"wp.data.select( 'core/editor' ).getReusableBlocks( ref )\", {\n\t\talternative: \"wp.data.select( 'core' ).getEntityRecords( 'postType', 'wp_block' )\",\n\t\tplugin: 'Gutenberg',\n\t\tversion: '4.4.0',\n\t} );\n\n\treturn __experimentalGetReusableBlocks( state );\n}\n"]}