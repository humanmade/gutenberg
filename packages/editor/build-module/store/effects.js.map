{"version":3,"sources":["/home/circleci/project/packages/editor/src/store/effects.js"],"names":["compact","last","has","speak","parse","getBlockType","switchToBlockType","doBlocksMatchTemplate","synchronizeBlocksWithTemplate","__","sprintf","setupEditorState","replaceBlocks","selectBlock","resetBlocks","setTemplateValidity","insertDefaultBlock","getBlock","getBlockRootClientId","getBlocks","getBlockCount","getPreviousBlockClientId","getSelectedBlock","getSelectedBlockCount","getTemplate","getTemplateLock","isValidTemplate","fetchReusableBlocks","saveReusableBlocks","deleteReusableBlocks","convertBlockToReusable","convertBlockToStatic","receiveReusableBlocks","requestPostUpdate","requestPostUpdateSuccess","requestPostUpdateFailure","trashPost","trashPostFailure","refreshPost","validateBlocksToTemplate","action","store","state","getState","template","templateLock","isBlocksValidToTemplate","blocks","selectPreviousBlock","selectPrevious","firstRemovedBlockClientId","clientIds","currentSelectedBlock","previousState","editor","present","past","rootClientId","blockClientIdToSelect","ensureDefaultBlock","REQUEST_POST_UPDATE","REQUEST_POST_UPDATE_SUCCESS","REQUEST_POST_UPDATE_FAILURE","TRASH_POST","TRASH_POST_FAILURE","REFRESH_POST","MERGE_BLOCKS","dispatch","firstBlockClientId","secondBlockClientId","blockA","blockB","blockType","name","merge","clientId","blocksWithTheSameType","length","updatedAttributes","attributes","slice","SETUP_EDITOR","post","edits","content","raw","isNewPost","status","setupAction","RESET_BLOCKS","SYNCHRONIZE_TEMPLATE","updatedBlockList","FETCH_REUSABLE_BLOCKS","SAVE_REUSABLE_BLOCK","DELETE_REUSABLE_BLOCK","RECEIVE_REUSABLE_BLOCKS","CONVERT_BLOCK_TO_STATIC","CONVERT_BLOCK_TO_REUSABLE","REMOVE_BLOCKS","REPLACE_BLOCKS","MULTI_SELECT","blockCount"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { compact, last, has } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { speak } from '@wordpress/a11y';\nimport {\n\tparse,\n\tgetBlockType,\n\tswitchToBlockType,\n\tdoBlocksMatchTemplate,\n\tsynchronizeBlocksWithTemplate,\n} from '@wordpress/blocks';\nimport { __, sprintf } from '@wordpress/i18n';\n\n/**\n * Internal dependencies\n */\nimport {\n\tsetupEditorState,\n\treplaceBlocks,\n\tselectBlock,\n\tresetBlocks,\n\tsetTemplateValidity,\n\tinsertDefaultBlock,\n} from './actions';\nimport {\n\tgetBlock,\n\tgetBlockRootClientId,\n\tgetBlocks,\n\tgetBlockCount,\n\tgetPreviousBlockClientId,\n\tgetSelectedBlock,\n\tgetSelectedBlockCount,\n\tgetTemplate,\n\tgetTemplateLock,\n\tisValidTemplate,\n} from './selectors';\nimport {\n\tfetchReusableBlocks,\n\tsaveReusableBlocks,\n\tdeleteReusableBlocks,\n\tconvertBlockToReusable,\n\tconvertBlockToStatic,\n\treceiveReusableBlocks,\n} from './effects/reusable-blocks';\nimport {\n\trequestPostUpdate,\n\trequestPostUpdateSuccess,\n\trequestPostUpdateFailure,\n\ttrashPost,\n\ttrashPostFailure,\n\trefreshPost,\n} from './effects/posts';\n\n/**\n * Block validity is a function of blocks state (at the point of a\n * reset) and the template setting. As a compromise to its placement\n * across distinct parts of state, it is implemented here as a side-\n * effect of the block reset action.\n *\n * @param {Object} action RESET_BLOCKS action.\n * @param {Object} store  Store instance.\n *\n * @return {?Object} New validity set action if validity has changed.\n */\nexport function validateBlocksToTemplate( action, store ) {\n\tconst state = store.getState();\n\tconst template = getTemplate( state );\n\tconst templateLock = getTemplateLock( state );\n\n\t// Unlocked templates are considered always valid because they act\n\t// as default values only.\n\tconst isBlocksValidToTemplate = (\n\t\t! template ||\n\t\ttemplateLock !== 'all' ||\n\t\tdoBlocksMatchTemplate( action.blocks, template )\n\t);\n\n\t// Update if validity has changed.\n\tif ( isBlocksValidToTemplate !== isValidTemplate( state ) ) {\n\t\treturn setTemplateValidity( isBlocksValidToTemplate );\n\t}\n}\n\n/**\n * Effect handler which will return a block select action to select the block\n * occurring before the selected block in the previous state, unless it is the\n * same block or the action includes a falsey `selectPrevious` option flag.\n *\n * @param {Object} action Action which had initiated the effect handler.\n * @param {Object} store  Store instance.\n *\n * @return {?Object} Block select action to select previous, if applicable.\n */\nexport function selectPreviousBlock( action, store ) {\n\t// if the action says previous block should not be selected don't do anything.\n\tif ( ! action.selectPrevious ) {\n\t\treturn;\n\t}\n\n\tconst firstRemovedBlockClientId = action.clientIds[ 0 ];\n\tconst state = store.getState();\n\tconst currentSelectedBlock = getSelectedBlock( state );\n\n\t// recreate the state before the block was removed.\n\tconst previousState = { ...state, editor: { present: last( state.editor.past ) } };\n\n\t// rootClientId of the removed block.\n\tconst rootClientId = getBlockRootClientId( previousState, firstRemovedBlockClientId );\n\n\t// Client ID of the block that was before the removed block or the\n\t// rootClientId if the removed block was first amongst its siblings.\n\tconst blockClientIdToSelect = getPreviousBlockClientId( previousState, firstRemovedBlockClientId ) || rootClientId;\n\n\t// Dispatch select block action if the currently selected block\n\t// is not already the block we want to be selected.\n\tif ( blockClientIdToSelect !== currentSelectedBlock ) {\n\t\treturn selectBlock( blockClientIdToSelect, -1 );\n\t}\n}\n\n/**\n * Effect handler which will return a default block insertion action if there\n * are no other blocks at the root of the editor. This is expected to be used\n * in actions which may result in no blocks remaining in the editor (removal,\n * replacement, etc).\n *\n * @param {Object} action Action which had initiated the effect handler.\n * @param {Object} store  Store instance.\n *\n * @return {?Object} Default block insert action, if no other blocks exist.\n */\nexport function ensureDefaultBlock( action, store ) {\n\tif ( ! getBlockCount( store.getState() ) ) {\n\t\treturn insertDefaultBlock();\n\t}\n}\n\nexport default {\n\tREQUEST_POST_UPDATE: ( action, store ) => {\n\t\trequestPostUpdate( action, store );\n\t},\n\tREQUEST_POST_UPDATE_SUCCESS: requestPostUpdateSuccess,\n\tREQUEST_POST_UPDATE_FAILURE: requestPostUpdateFailure,\n\tTRASH_POST: ( action, store ) => {\n\t\ttrashPost( action, store );\n\t},\n\tTRASH_POST_FAILURE: trashPostFailure,\n\tREFRESH_POST: ( action, store ) => {\n\t\trefreshPost( action, store );\n\t},\n\tMERGE_BLOCKS( action, store ) {\n\t\tconst { dispatch } = store;\n\t\tconst state = store.getState();\n\t\tconst [ firstBlockClientId, secondBlockClientId ] = action.blocks;\n\t\tconst blockA = getBlock( state, firstBlockClientId );\n\t\tconst blockB = getBlock( state, secondBlockClientId );\n\t\tconst blockType = getBlockType( blockA.name );\n\n\t\t// Only focus the previous block if it's not mergeable\n\t\tif ( ! blockType.merge ) {\n\t\t\tdispatch( selectBlock( blockA.clientId ) );\n\t\t\treturn;\n\t\t}\n\n\t\t// We can only merge blocks with similar types\n\t\t// thus, we transform the block to merge first\n\t\tconst blocksWithTheSameType = blockA.name === blockB.name ?\n\t\t\t[ blockB ] :\n\t\t\tswitchToBlockType( blockB, blockA.name );\n\n\t\t// If the block types can not match, do nothing\n\t\tif ( ! blocksWithTheSameType || ! blocksWithTheSameType.length ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Calling the merge to update the attributes and remove the block to be merged\n\t\tconst updatedAttributes = blockType.merge(\n\t\t\tblockA.attributes,\n\t\t\tblocksWithTheSameType[ 0 ].attributes\n\t\t);\n\n\t\tdispatch( selectBlock( blockA.clientId, -1 ) );\n\t\tdispatch( replaceBlocks(\n\t\t\t[ blockA.clientId, blockB.clientId ],\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t...blockA,\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\t...blockA.attributes,\n\t\t\t\t\t\t...updatedAttributes,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t...blocksWithTheSameType.slice( 1 ),\n\t\t\t]\n\t\t) );\n\t},\n\tSETUP_EDITOR( action, store ) {\n\t\tconst { post, edits } = action;\n\t\tconst state = store.getState();\n\n\t\t// In order to ensure maximum of a single parse during setup, edits are\n\t\t// included as part of editor setup action. Assume edited content as\n\t\t// canonical if provided, falling back to post.\n\t\tlet content;\n\t\tif ( has( edits, [ 'content' ] ) ) {\n\t\t\tcontent = edits.content;\n\t\t} else {\n\t\t\tcontent = post.content.raw;\n\t\t}\n\n\t\tlet blocks = parse( content );\n\n\t\t// Apply a template for new posts only, if exists.\n\t\tconst isNewPost = post.status === 'auto-draft';\n\t\tconst template = getTemplate( state );\n\t\tif ( isNewPost && template ) {\n\t\t\tblocks = synchronizeBlocksWithTemplate( blocks, template );\n\t\t}\n\n\t\tconst setupAction = setupEditorState( post, blocks );\n\n\t\treturn compact( [\n\t\t\tsetupAction,\n\n\t\t\t// TODO: This is temporary, necessary only so long as editor setup\n\t\t\t// is a separate action from block resetting.\n\t\t\t//\n\t\t\t// See: https://github.com/WordPress/gutenberg/pull/9403\n\t\t\tvalidateBlocksToTemplate( setupAction, store ),\n\t\t] );\n\t},\n\tRESET_BLOCKS: [\n\t\tvalidateBlocksToTemplate,\n\t],\n\tSYNCHRONIZE_TEMPLATE( action, { getState } ) {\n\t\tconst state = getState();\n\t\tconst blocks = getBlocks( state );\n\t\tconst template = getTemplate( state );\n\t\tconst updatedBlockList = synchronizeBlocksWithTemplate( blocks, template );\n\n\t\treturn resetBlocks( updatedBlockList );\n\t},\n\tFETCH_REUSABLE_BLOCKS: ( action, store ) => {\n\t\tfetchReusableBlocks( action, store );\n\t},\n\tSAVE_REUSABLE_BLOCK: ( action, store ) => {\n\t\tsaveReusableBlocks( action, store );\n\t},\n\tDELETE_REUSABLE_BLOCK: ( action, store ) => {\n\t\tdeleteReusableBlocks( action, store );\n\t},\n\tRECEIVE_REUSABLE_BLOCKS: receiveReusableBlocks,\n\tCONVERT_BLOCK_TO_STATIC: convertBlockToStatic,\n\tCONVERT_BLOCK_TO_REUSABLE: convertBlockToReusable,\n\tREMOVE_BLOCKS: [\n\t\tselectPreviousBlock,\n\t\tensureDefaultBlock,\n\t],\n\tREPLACE_BLOCKS: [\n\t\tensureDefaultBlock,\n\t],\n\tMULTI_SELECT: ( action, { getState } ) => {\n\t\tconst blockCount = getSelectedBlockCount( getState() );\n\n\t\tspeak( sprintf( __( '%s blocks selected.' ), blockCount ), 'assertive' );\n\t},\n};\n"]}