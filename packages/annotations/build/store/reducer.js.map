{"version":3,"sources":["/home/circleci/project/packages/annotations/src/store/reducer.js"],"names":["filterWithReference","collection","predicate","filteredCollection","filter","length","isValidAnnotationRange","annotation","start","end","annotations","state","all","byBlockClientId","action","type","blockClientId","newAnnotation","id","richTextIdentifier","source","selector","range","previousAnnotationsForBlock","annotationId","annotationForBlock","idsToRemove","allAnnotations","push","includes"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { isNumber, mapValues } from 'lodash';\n\n/**\n * Filters an array based on the predicate, but keeps the reference the same if\n * the array hasn't changed.\n *\n * @param {Array}    collection The collection to filter.\n * @param {Function} predicate  Function that determines if the item should stay\n *                              in the array.\n * @return {Array} Filtered array.\n */\nfunction filterWithReference( collection, predicate ) {\n\tconst filteredCollection = collection.filter( predicate );\n\n\treturn collection.length === filteredCollection.length ? collection : filteredCollection;\n}\n\n/**\n * Verifies whether the given annotations is a valid annotation.\n *\n * @param {Object} annotation The annotation to verify.\n * @return {boolean} Whether the given annotation is valid.\n */\nfunction isValidAnnotationRange( annotation ) {\n\treturn isNumber( annotation.start ) &&\n\t\tisNumber( annotation.end ) &&\n\t\tannotation.start <= annotation.end;\n}\n\n/**\n * Reducer managing annotations.\n *\n * @param {Array} state The annotations currently shown in the editor.\n * @param {Object} action Dispatched action.\n *\n * @return {Array} Updated state.\n */\nexport function annotations( state = { all: [], byBlockClientId: {} }, action ) {\n\tswitch ( action.type ) {\n\t\tcase 'ANNOTATION_ADD':\n\t\t\tconst blockClientId = action.blockClientId;\n\t\t\tconst newAnnotation = {\n\t\t\t\tid: action.id,\n\t\t\t\tblockClientId,\n\t\t\t\trichTextIdentifier: action.richTextIdentifier,\n\t\t\t\tsource: action.source,\n\t\t\t\tselector: action.selector,\n\t\t\t\trange: action.range,\n\t\t\t};\n\n\t\t\tif ( newAnnotation.selector === 'range' && ! isValidAnnotationRange( newAnnotation.range ) ) {\n\t\t\t\treturn state;\n\t\t\t}\n\n\t\t\tconst previousAnnotationsForBlock = state.byBlockClientId[ blockClientId ] || [];\n\n\t\t\treturn {\n\t\t\t\tall: [\n\t\t\t\t\t...state.all,\n\t\t\t\t\tnewAnnotation,\n\t\t\t\t],\n\t\t\t\tbyBlockClientId: {\n\t\t\t\t\t...state.byBlockClientId,\n\t\t\t\t\t[ blockClientId ]: [ ...previousAnnotationsForBlock, action.id ],\n\t\t\t\t},\n\t\t\t};\n\n\t\tcase 'ANNOTATION_REMOVE':\n\t\t\treturn {\n\t\t\t\tall: state.all.filter( ( annotation ) => annotation.id !== action.annotationId ),\n\n\t\t\t\t// We use filterWithReference to not refresh the reference if a block still has\n\t\t\t\t// the same annotations.\n\t\t\t\tbyBlockClientId: mapValues( state.byBlockClientId, ( annotationForBlock ) => {\n\t\t\t\t\treturn filterWithReference( annotationForBlock, ( annotationId ) => {\n\t\t\t\t\t\treturn annotationId !== action.annotationId;\n\t\t\t\t\t} );\n\t\t\t\t} ),\n\t\t\t};\n\n\t\tcase 'ANNOTATION_REMOVE_SOURCE':\n\t\t\tconst idsToRemove = [];\n\n\t\t\tconst allAnnotations = state.all.filter( ( annotation ) => {\n\t\t\t\tif ( annotation.source === action.source ) {\n\t\t\t\t\tidsToRemove.push( annotation.id );\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t} );\n\n\t\t\treturn {\n\t\t\t\tall: allAnnotations,\n\t\t\t\tbyBlockClientId: mapValues( state.byBlockClientId, ( annotationForBlock ) => {\n\t\t\t\t\treturn filterWithReference( annotationForBlock, ( annotationId ) => {\n\t\t\t\t\t\treturn ! idsToRemove.includes( annotationId );\n\t\t\t\t\t} );\n\t\t\t\t} ),\n\t\t\t};\n\t}\n\n\treturn state;\n}\n\nexport default annotations;\n"]}