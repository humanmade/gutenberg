{"version":3,"sources":["/home/circleci/project/packages/annotations/src/store/selectors.js"],"names":["createSelector","__experimentalGetAnnotationsForBlock","state","blockClientId","all","filter","annotation","selector","byBlockClientId","__experimentalGetAnnotationsForRichText","richTextIdentifier","map","range","other","__experimentalGetAnnotations"],"mappings":";;;AAAA;;;AAGA,OAAOA,cAAP,MAA2B,QAA3B;AAEA;;;;;;;;;AAQA,OAAO,IAAMC,oCAAoC,GAAGD,cAAc,CACjE,UAAEE,KAAF,EAASC,aAAT,EAA4B;AAC3B,SAAOD,KAAK,CAACE,GAAN,CAAUC,MAAV,CAAkB,UAAEC,UAAF,EAAkB;AAC1C,WAAOA,UAAU,CAACC,QAAX,KAAwB,OAAxB,IAAmCD,UAAU,CAACH,aAAX,KAA6BA,aAAvE;AACA,GAFM,CAAP;AAGA,CALgE,EAMjE,UAAED,KAAF,EAASC,aAAT;AAAA,SAA4B,CAC3BD,KAAK,CAACM,eAAN,CAAuBL,aAAvB,CAD2B,CAA5B;AAAA,CANiE,CAA3D;AAWP;;;;;;;;;;;;;AAYA,OAAO,IAAMM,uCAAuC,GAAGT,cAAc,CACpE,UAAEE,KAAF,EAASC,aAAT,EAAwBO,kBAAxB,EAAgD;AAC/C,SAAOR,KAAK,CAACE,GAAN,CAAUC,MAAV,CAAkB,UAAEC,UAAF,EAAkB;AAC1C,WAAOA,UAAU,CAACC,QAAX,KAAwB,OAAxB,IACND,UAAU,CAACH,aAAX,KAA6BA,aADvB,IAENO,kBAAkB,KAAKJ,UAAU,CAACI,kBAFnC;AAGA,GAJM,EAIHC,GAJG,CAIE,UAAEL,UAAF,EAAkB;AAAA,QAClBM,KADkB,GACEN,UADF,CAClBM,KADkB;AAAA,QACRC,KADQ,4BACEP,UADF;;AAG1B,6BACIM,KADJ,EAEIC,KAFJ;AAIA,GAXM,CAAP;AAYA,CAdmE,EAepE,UAAEX,KAAF,EAASC,aAAT;AAAA,SAA4B,CAC3BD,KAAK,CAACM,eAAN,CAAuBL,aAAvB,CAD2B,CAA5B;AAAA,CAfoE,CAA9D;AAoBP;;;;;;;AAMA,OAAO,SAASW,4BAAT,CAAuCZ,KAAvC,EAA+C;AACrD,SAAOA,KAAK,CAACE,GAAb;AACA","sourcesContent":["/**\n * External dependencies\n */\nimport createSelector from 'rememo';\n\n/**\n * Returns the annotations for a specific client ID.\n *\n * @param {Object} state Editor state.\n * @param {string} clientId The ID of the block to get the annotations for.\n *\n * @return {Array} The annotations applicable to this block.\n */\nexport const __experimentalGetAnnotationsForBlock = createSelector(\n\t( state, blockClientId ) => {\n\t\treturn state.all.filter( ( annotation ) => {\n\t\t\treturn annotation.selector === 'block' && annotation.blockClientId === blockClientId;\n\t\t} );\n\t},\n\t( state, blockClientId ) => [\n\t\tstate.byBlockClientId[ blockClientId ],\n\t]\n);\n\n/**\n * Returns the annotations that apply to the given RichText instance.\n *\n * Both a blockClientId and a richTextIdentifier are required. This is because\n * a block might have multiple `RichText` components. This does mean that every\n * block needs to implement annotations itself.\n *\n * @param {Object} state              Editor state.\n * @param {string} blockClientId      The client ID for the block.\n * @param {string} richTextIdentifier Unique identifier that identifies the given RichText.\n * @return {Array} All the annotations relevant for the `RichText`.\n */\nexport const __experimentalGetAnnotationsForRichText = createSelector(\n\t( state, blockClientId, richTextIdentifier ) => {\n\t\treturn state.all.filter( ( annotation ) => {\n\t\t\treturn annotation.selector === 'range' &&\n\t\t\t\tannotation.blockClientId === blockClientId &&\n\t\t\t\trichTextIdentifier === annotation.richTextIdentifier;\n\t\t} ).map( ( annotation ) => {\n\t\t\tconst { range, ...other } = annotation;\n\n\t\t\treturn {\n\t\t\t\t...range,\n\t\t\t\t...other,\n\t\t\t};\n\t\t} );\n\t},\n\t( state, blockClientId ) => [\n\t\tstate.byBlockClientId[ blockClientId ],\n\t]\n);\n\n/**\n * Returns all annotations in the editor state.\n *\n * @param {Object} state Editor state.\n * @return {Array} All annotations currently applied.\n */\nexport function __experimentalGetAnnotations( state ) {\n\treturn state.all;\n}\n"]}